; $Id: dyn_data_elab.pro,v 1.4 2003/06/10 18:32:20 riccardi Exp $


;+
; DYN_DATA_ELAB
;
; this procedure elaborates the data obtained by dyn_data_acquisition.
; The FFT of the acquired signals are computed.
; The single actuator or modal FFT are returned, depending
; on the setting of the keyword MODAL_TF.
;
;
; err = dyn_data_elab(data, fft_data)
;
; INPUTS
;
;   data:         structure obtained by the dyn_data_acquisition
;                 function.
;
; OUTPUTS
;
;   err:          scalar long int. Error code (see adsec_error
;                 structure in init_gvar.pro)
;
;   fft_data:     named variable on input. On output, structure
;                 containing the FFT of the acquired signals
;
; KEYWORDS
;
;   MODAL_TF:    if set the modal tranfer functions are computed,
;                 otherwise the single-actuator tranfer functions are
;                 returned.
;
;   MODE_INDEX:   integer vector used when the modal_fft keyword is set.
;                 The modal ffts are computed only for the modes indexed
;                 by mode_index.
;
;	ADSEC_SAVE:	  structure adsec used when the data were acquired.
;				 If not passed the current adsec structure is used.
;
;
; HISTORY
;
;   Written by A. Riccardi (AR)
;   Osservatorio Asrofisico di Arcetri, ITALY
;   <riccardi@arcetri.astro.it>
;
;   13 Mar 2002, AR
;     Bug fixed in the CONT keyword setting of the MESSAGE call.
;-
;
function dyn_data_elab, data, fft_data, MODAL_TF=modal_tf, MODE_INDEX=mode_index, ADSEC_SAVE=adsec_save


@adsec_common

if n_elements(adsec_save) eq 0 then adsec_save = adsec

if test_type(data, /STRUCTURE, N_EL=n_el) then begin
    message, "data must be a structure generated by dyn_data_elab" $
           , CONT=(sc.debug eq 0B)
    return, adsec_error.input_type
endif
if n_el ne 1 then begin
    message, "data can not be a vector of structures" $
           , CONT=(sc.debug eq 0B)
    return, adsec_error.input_type
endif


position     = data.position
ctrl_current = data.ctrl_current
command      = data.sequence

;; recover the number of time samples taken in the acquisition
s = size(command)
n_samples = s[1]

if keyword_set(modal_tf) then begin
    ;; a modal tranfer function computation is requested, hence
    ;; a modal decomposition of the aquired data is needed
    ;;
    if n_elements(mode_index) eq 0 then mode_index=indgen(adsec_save.n_actuators)

    position     = transpose(adsec_save.ff_p_svec[mode_index,*]) ## temporary(position)
    ;ctrl_current = transpose(adsec_save.ff_f_svec[mode_index,*]) ## temporary(ctrl_current)
    ctrl_current = -transpose(adsec_save.ff_p_svec[mode_index,*]) ## temporary(ctrl_current)

    if data.curr_excite then $
        command = transpose(adsec_save.ff_f_svec[mode_index,*]) ## temporary(command) $
    else $
        command = transpose(adsec_save.ff_p_svec[mode_index,*]) ## temporary(command)
endif

dec = data.decimation
n_freq = n_samples/2+1
freq_step = 1.0/(dec+1)/n_samples/adsec_save.sampling_time
freq_vector = findgen(n_freq)*freq_step

;; allocate memory for the fft's
;;
fft_data = $
    { $
        modal       : data.modal, $
        modal_fft   : keyword_set(modal_tf), $
        curr_excite : data.curr_excite, $
        index       : data.index, $
        amp         : data.amp, $
        n_rep       : data.n_rep, $
        freq_range  : data.freq_range, $
        decimation  : data.decimation, $
        freq_vector: freq_vector, $
        fft_command: complexarr(n_freq, adsec_save.n_actuators), $
        fft_position: complexarr(n_freq, adsec_save.n_actuators), $
        fft_ctrl_current: complexarr(n_freq, adsec_save.n_actuators) $
    }

if keyword_set(modal_tf) then begin
    for i=0,n_elements(mode_index)-1 do begin
        fft_data.fft_command[*,mode_index[i]] = (fft(command[*,i]))[0:n_freq-1]
        fft_data.fft_position[*,mode_index[i]] = (fft(position[*,i]))[0:n_freq-1]
        fft_data.fft_ctrl_current[*,mode_index[i]] = (fft(ctrl_current[*,i]))[0:n_freq-1]
    endfor
endif else begin
    for i=0,adsec_save.n_actuators-1 do begin
        fft_data.fft_command[*,i] = (fft(command[*,i]))[0:n_freq-1]
        fft_data.fft_position[*,i] = (fft(position[*,i]))[0:n_freq-1]
        fft_data.fft_ctrl_current[*,i] = (fft(ctrl_current[*,i]))[0:n_freq-1]
    endfor
endelse

end
