/*
 * This class implements the state machine of the AdSec Arbitrator
 * using as core FSM the code generated by FSMC
 * based on the FSM description in AdSecArbFsmCore.fsm
 *
 */

#include "AdSecFsm.h"
#include "arblib/adSecArb/AdSecCommands.h"
#include "AdSecCommandsImpl.h"

using namespace Arcetri::Arbitrator;


AdSecFsm::AdSecFsm(unsigned int commandHistoryMaxSize, string ident): AbstractFsm(commandHistoryMaxSize, ident) 
{ 
  using namespace Arcetri::AdSec_Arbitrator;
// This defines the event map table. When new events are added to the FSM,
// They must be added to the table below.

  EvtTable[(OpCode)AdSecOpCodes::ON_CMD]=On;
  EvtTable[(OpCode)AdSecOpCodes::OFF_CMD]=Off;
  EvtTable[(OpCode)AdSecOpCodes::LOAD_PROGRAM_CMD]=LoadProgram;
  EvtTable[(OpCode)AdSecOpCodes::RESET_CMD]=Reset;
  EvtTable[(OpCode)AdSecOpCodes::SET_FLAT_CHOP_CMD]=SetFlatChop;
  EvtTable[(OpCode)AdSecOpCodes::SET_FLAT_AO_CMD]=SetFlatAo;
  EvtTable[(OpCode)AdSecOpCodes::REST_CMD]=Rest;
  EvtTable[(OpCode)AdSecOpCodes::APPLY_COMMANDS_CMD]=ApplyCommands;
  EvtTable[(OpCode)AdSecOpCodes::CHOP_TO_AO_CMD]=ChopToAo;
  EvtTable[(OpCode)AdSecOpCodes::AO_TO_CHOP_CMD]=AoToChop;
  EvtTable[(OpCode)AdSecOpCodes::RUN_AO_CMD]=RunAo;
  EvtTable[(OpCode)AdSecOpCodes::STOP_AO_CMD]=StopAo;
  EvtTable[(OpCode)AdSecOpCodes::RUN_CHOP_CMD]=RunChop;
  EvtTable[(OpCode)AdSecOpCodes::STOP_CHOP_CMD]=StopChop;
  EvtTable[(OpCode)AdSecOpCodes::SET_GAIN_CMD]=SetGain;
  EvtTable[(OpCode)AdSecOpCodes::SET_DISTURB_CMD]=SetDisturb;
  EvtTable[(OpCode)AdSecOpCodes::LOAD_SHAPE_CMD]=LoadShape;
  EvtTable[(OpCode)AdSecOpCodes::SAVE_SHAPE_CMD]=SaveShape;
  EvtTable[(OpCode)AdSecOpCodes::SET_REC_MAT_CMD]=SetRecMat;
  EvtTable[(OpCode)AdSecOpCodes::SAVE_SLOPES_CMD]=SaveSlopes;
  EvtTable[(OpCode)AdSecOpCodes::SAVE_STATUS_CMD]=SaveStatus;
  EvtTable[(OpCode)AdSecOpCodes::DATA_DECIMATION_CMD]=SetDataDecimation;
  EvtTable[(OpCode)AdSecOpCodes::SELECT_FOCAL_STATION_CMD]=SelectFocalStation;
  EvtTable[(OpCode)AdSecOpCodes::RECOVER_SKIP_FRAME_CMD]=RecoverSkipFrame;
  EvtTable[(OpCode)AdSecOpCodes::PAUSE_AO_CMD]=PauseAo;
  EvtTable[(OpCode)AdSecOpCodes::RESUME_AO_CMD]=ResumeAo;
  EvtTable[(OpCode)AdSecOpCodes::TT_OFFLOAD_CMD]=TTOffLoad;
  EvtTable[(OpCode)AdSecOpCodes::SET_ZERNIKES_CMD]=SetZernikes;
  EvtTable[(OpCode)AdSecOpCodes::CALIBRATE_CMD]=Calibrate;

  EvtTable[(OpCode)BasicOpCodes::RECOVER_PANIC]=RecoverPanic;
  EvtTable[(OpCode)BasicOpCodes::RECOVER_FAILURE]=RecoverFailure;
  EvtTable[(OpCode)BasicOpCodes::FORCE_FAILURE]=ForceFailure;
  EvtTable[(OpCode)BasicOpCodes::FORCE_PANIC]=ForcePanic;

  forceState(PowerOff);
}

// Implementation of pure virtual base class methods
void AdSecFsm::trigger(OpCode code) 
{
    if(EvtTable.count(code)> 0) {
	    Event e = EvtTable[code];
	    A(e);
    } else {
       throw ArbitratorException("Event table inconsistency",ARB_GENERIC_ERROR);
    }
}

void AdSecFsm::forceFailure() 
{
	trigger(BasicOpCodes::FORCE_FAILURE);
}

void AdSecFsm::forcePanic() 
{
	trigger(BasicOpCodes::FORCE_PANIC);
}

string AdSecFsm::currentStateAsString() 
{ 
	return string(stateName(currentState())); 
}


// the workaround below is needed to avoid an error due to
// the const method definition
bool AdSecFsm::processCommand() const
{ 
bool ret;

   AdSecFsm *pt=const_cast<AdSecFsm *>(this);
	ret =  pt->AbstractFsm::processCommand(); 

   if(ret)
      _logger->log(Logger::LOG_LEV_DEBUG,"processCommand() retured TRUE (success)");
   else
       _logger->log(Logger::LOG_LEV_DEBUG,"processCommand() retured FALSE (failure)");
   return ret;
}


void AdSecFsm::forceRest()
{
   // Immediate RIP
 try{
    AdSecArbitrator* adSecArb = (AdSecArbitrator*) AbstractArbitrator::getInstance();
    FastDiagnSystem *fastdiag = (FastDiagnSystem*) adSecArb->getSystems()["FASTDIAGN"];
    AdamSystem *adam = (AdamSystem*) adSecArb->getSystems()[ADAMSYSTEM_NAME];

    fastdiag->setDiagThresholdsSet(FASTDIAGNSYSTEM_RIPPING_SET);
    _logger->log(Logger::LOG_LEV_INFO,"forceRest(): disabling coils");
    adam->disableCoils();
    adSecArb->setCoilsEnabled(false);

    // Queue a Rest command on the FSM
    // Use a catch all to be sure that the thresholds are put back in the correct state
    try {
        Command* cmd = new AdSec_Arbitrator::Rest(5000);
        adSecArb->getArbitratorInterface(adSecArb->MyFullName())->requestCommand(cmd);
    } catch (...) { }
    
    fastdiag->setDiagThresholdsSet(FASTDIAGNSYSTEM_PREVIOUS_SET);

    // Notify interested parties
    Error error("COILS DISABLED", true);
    adSecArb->notifyClients((Alert*)&error);

 } catch (AOException &e) {
     _logger->log(Logger::LOG_LEV_ERROR,"forceRest(): cannot force shell RIP: %s", e.what().c_str());
 }

}
