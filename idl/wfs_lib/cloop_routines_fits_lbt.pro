;$Id: cloop_routines_fits_p45.pro,v 1.5 2009/11/02 18:00:39 labot Exp $$
;+
;; generate_masks_BCU
;
; Reads from disk the previously generated
; pupil masks and extracts the indices of
; the relevant pixels (to index the pixels
; into the EDC-1000 camera frame).
;
; This _BCU version only looks at the "1" pupil (the one in the quadrant A)
;
; parameters:  ccd_w    int          (in)    - quadrant width
;              ccd_h    int          (in)    - quadrant height
;              lonarr   long         (out)   - (4,*) array of indices, one for each pupil
; Use the text file generated by "faipupilla.py"
;-

function generate_masks_BCU, ccd_w, ccd_h, BINNING=BINNING, INPREFIX = INPREFIX

	; read pupil information
	print,"Generate masks, binning = ",BINNING
	read_pup_from_disk_BCU, ave_radius, c_coord, BINNING=BINNING, INPREFIX = INPREFIX

	print,"Average radius: ",ave_radius
	print,"Center coords:", c_coord
	; calculate radii and coordinates
	generate_index_BCU, ave_radius, c_coord, ccd_w, ccd_h, ind_pup

	print, c_coord
	print, ave_radius
	return, ind_pup
END

; generate_masks_fits

pro generate_masks_fits, ccd_w, ccd_h, OUTPREFIX=OUTPREFIX, INPREFIX=INPREFIX, BINNING=BINNING

   ind_pup = generate_masks_BCU( ccd_w/BINNING, ccd_h/BINNING, INPREFIX = INPREFIX, BINNING=BINNING)

  
   hdr = CREATE_STRUCT('TYPE', 'PUPIL')
   writefits, outprefix+"pup1.fits", reform(ind_pup[0,*]), hdr
   writefits, outprefix+"pup2.fits", reform(ind_pup[1,*]), hdr
   writefits, outprefix+"pup3.fits", reform(ind_pup[2,*]), hdr
   writefits, outprefix+"pup4.fits", reform(ind_pup[3,*]), hdr
end


;+
;; read_pup_from_disk_BCU
;
; Reads pupil information from disk (generated
; with the acq_pupils procedure). Finds the x,y
; center coordinates for each pupil, and an
; average radius.
;
; parameters :	ave_radius    float       (out) - average radius
;               c_coord       fltarr(4,2) (out) - four x,y coordinates
;-

PRO read_pup_from_disk_BCU, ave_radius, c_coord, BINNING=BINNING, INPREFIX = INPREFIX

	; Initialize arrays
	radii = fltarr(4)
	c_coord = fltarr(4,2)

	if not keyword_set(BINNING) then begin
		print,"Error: BINNING keywork is not set"
		exit
	endif
	
	; read pupil data
	file_radix = INPREFIX

    print,"Reading file "+file_radix+'pupdata.txt'

    pupdata = read_ascii(file_radix+'pupdata.txt')

    pupdata = pupdata.field1

    radii        = pupdata[0,*]
    c_coord[*,0] = pupdata[1,*]
    c_coord[*,1] = pupdata[2,*]


    print,"Read:"
    print,"Radii:", radii
    print,"c_coord_x:",c_coord[*,0]
    print,"c_coord_y:",c_coord[*,1]

	; calculate the average pupil radius
	; The radii used in this calculation must be similar:
	; do a stdev check and warn if

	; ****

;	std_radius = stdev( radii, ave_radius)
	ave_radius = radii[1]
;	if std_radius GE 0.8 then begin
;		print,"Error: different pupil radii (stdev > 0.2 pixels)",radii
;		return
;	endif

	return
END

;+
; generate_index_BCU
;
; Starting from radius and x,y center coordinates,
; generates an array of indices to extract the pupils
; from an EDC-1000 frame.
; The output result is a long array (4,n). Each line
; of this array is composed by the pixel indices of
; the correspoding pupil.
;
; parameters:  radius   float        (in)    - pupil radius
;              c_coord  fltarr(4,2)  (in)    - x,y center coordinates
;              ccd_w    int          (in)    - quadrant width
;              ccd_h    int          (in)    - quadrant height
;              ind      fltarr(4,n)  (out)   - pixel indices for each pupil
;-

PRO generate_index_BCU, radius, c_coord, ccd_w, ccd_h, ind

	EEV39 = 1

	; Create a square mask for a single pupil.7
	; Mask has 1's inside the pupil and 0's outside
	; (border pixels are included  ;**** . To mask them out, change LE to LT and GT to GE).

    ; Center in the middle of a pixel
    centerx = ccd_w/4 +0.5
    centery = ccd_h/4 +0.5
    ;radius = 31.0 / fix(80/ccd_w) /2.0

    mask = fltarr(ccd_w/2, ccd_h/2)
    for x=0,ccd_w/2-1 do begin
        for y=0,ccd_h/2-1 do begin
            d = sqrt( (x+0.5-centerx)^2 + (y+0.5-centery)^2)
            if d le radius then mask[x,y] = 1
        endfor
    endfor
    idx = where(mask eq 1, count_pup)

    ; DISCARD a pixel if we have an odd number!
;	if count_pup MOD 2 then begin
;        idx = idx[0: n_elements(idx)-2]
;        mask = mask*0
;        mask[idx]=1
;	endif
;    idx = where(mask eq 1, count_pup)

	; Initialize result array. <count_pup> is the number of pixel for each pupil
	ind = lonarr( 4, count_pup)

	; Repeat for each pupil
	for i=0,3 do begin
		frame = fltarr( CCD_W , CCD_H)

        frame[0:ccd_w/2-1, 0:ccd_h/2-1] = mask
        c_coord[i,0] = fix(c_coord[i,0]) +0.5
        c_coord[i,1] = fix(c_coord[i,1]) +0.5

        dx = c_coord[i,0] - centerx +1
        dy = c_coord[i,1] - centery
        frame = shift( frame,  dx, dy)

        ind[i,*] = where( frame eq 1)

	endfor


	return
END



