/*
 * This class implements the state machine of the Wfs Arbitrator
 * using as core FSM the code generated by FSMC
 * based on the FSM description in WfsFsmCore.fsm
 *
 */

#include "WfsFsm.h"
#include "arblib/wfsArb/WfsCommands.h"
#include "WfsCommandsImpl.h"

using namespace Arcetri::Arbitrator;
using namespace Arcetri::Wfs_Arbitrator;


WfsFsm::WfsFsm(unsigned int commandHistoryMaxSize, string ident): AbstractFsm(commandHistoryMaxSize, ident)
{
// This defines the event map table. When new events are added to the FSM,
// They must be added to the table below.

  EvtTable[(OpCode)WfsOpCodes::OPERATE_CMD]=Operate;
  EvtTable[(OpCode)WfsOpCodes::OFF_CMD]=Off;
  EvtTable[(OpCode)WfsOpCodes::PREPARE_ACQUIRE_REF_CMD]=PrepareAcquireRef;
  EvtTable[(OpCode)WfsOpCodes::ACQUIRE_REF_CMD]=AcquireRef;
  EvtTable[(OpCode)WfsOpCodes::CLOSE_LOOP_CMD]=CloseLoop;
  EvtTable[(OpCode)WfsOpCodes::PAUSE_LOOP_CMD]=PauseLoop;
  EvtTable[(OpCode)WfsOpCodes::RESUME_LOOP_CMD]=ResumeLoop;
  EvtTable[(OpCode)WfsOpCodes::STOP_LOOP_CMD]=StopLoop;
  EvtTable[(OpCode)WfsOpCodes::MODIFY_AO_CMD]=ModifyAO;
  EvtTable[(OpCode)WfsOpCodes::REFINE_LOOP_CMD]=RefineLoop;
  EvtTable[(OpCode)WfsOpCodes::CALIBRATE_HODARK_CMD]=CalibrateHODark;
  EvtTable[(OpCode)WfsOpCodes::CALIBRATE_MOVEMENTS_CMD]=CalibrateTVDark;
  EvtTable[(OpCode)WfsOpCodes::CALIBRATE_SLOPENULL_CMD]=CalibrateSlopenull;
  EvtTable[(OpCode)WfsOpCodes::CALIBRATE_TVDARK_CMD]=CalibrateTVDark;
  EvtTable[(OpCode)WfsOpCodes::GET_TV_SNAP_CMD]=GetTVSnap;
  EvtTable[(OpCode)WfsOpCodes::SAVE_STATUS_CMD]=SaveStatus;
  EvtTable[(OpCode)WfsOpCodes::SAVE_OPTLOOPDATA_CMD]=SaveOptLoopData;
  EvtTable[(OpCode)WfsOpCodes::ENABLE_DISTURB_CMD]=EnableDisturb;
  EvtTable[(OpCode)WfsOpCodes::OFFSET_XY]=OffsetXY;
  EvtTable[(OpCode)WfsOpCodes::OFFSET_Z]=OffsetZ;
  EvtTable[(OpCode)WfsOpCodes::CORRECT_MODES]=CorrectModes;
  EvtTable[(OpCode)WfsOpCodes::EMERGENCY_OFF]=EmergencyOff;
  EvtTable[(OpCode)WfsOpCodes::CHECK_REF_CMD]=CheckRef;
  EvtTable[(OpCode)WfsOpCodes::SETSOURCE_CMD]=SetSource;
  EvtTable[(OpCode)WfsOpCodes::CALIBRATE_IRTCDARK_CMD]=CalibrateIRTCDark;
  EvtTable[(OpCode)WfsOpCodes::CALIBRATE_PISCESDARK_CMD]=CalibratePISCESDark;
  EvtTable[(OpCode)WfsOpCodes::PREPARE_ADSEC_CMD]=PrepareAdsec;
  EvtTable[(OpCode)WfsOpCodes::STOPLOOP_ADSEC_CMD]=StopLoopAdsec;
  EvtTable[(OpCode)WfsOpCodes::ANTIDRIFT_CMD]=AntiDrift;
  EvtTable[(OpCode)WfsOpCodes::AUTOTRACK_CMD]=AutoTrack;
  EvtTable[(OpCode)WfsOpCodes::OPTIMIZE_GAIN_CMD]=OptimizeGain;

  EvtTable[(OpCode)BasicOpCodes::RECOVER_PANIC]=RecoverPanic;
  EvtTable[(OpCode)BasicOpCodes::RECOVER_FAILURE]=RecoverFailure;
  EvtTable[(OpCode)BasicOpCodes::FORCE_FAILURE]=ForceFailure;
  EvtTable[(OpCode)BasicOpCodes::FORCE_PANIC]=ForcePanic;

  forceState(PowerOff);
}

// Implementation of pure virtual base class methods
void WfsFsm::trigger(OpCode code)
{   
    if(EvtTable.count(code)> 0) {
       Event e = EvtTable[code];
       A(e);
    } else { 
       throw ArbitratorException("Event table inconsistency",ARB_GENERIC_ERROR);
    }
}

void WfsFsm::forcePanic()
{  
   trigger(BasicOpCodes::FORCE_PANIC);
}

string WfsFsm::currentStateAsString()
{  
   return string(stateName(currentState()));
}


void WfsFsm::forceFailure()
{

    // Open loop if needed
    if (currentStateAsString() == "LoopClosed") {

       WfsSystem* wfs = (WfsSystem *)AbstractArbitrator::getInstance()->getSystems()["WFS"];
       MastDiagnSystem* mastDiagn = (MastDiagnSystem *)AbstractArbitrator::getInstance()->getSystems()["MASTDIAGN"];
       AdSecSystem* adSec = (AdSecSystem *)AbstractArbitrator::getInstance()->getSystems()["ADSEC"];

       AbstractSystemCommandResult res = wfs->stopLoop();
       if (res == SysCmdSuccess)  {
          mastDiagn->openLoop();
          adSec->openLoop(false);
          forceState(AOSet);
       }
    }

    trigger(BasicOpCodes::FORCE_FAILURE);
}


// the workaround below is needed to avoid an error due to
// the const method definition
bool WfsFsm::processCommand() const
{ 
bool ret;

   WfsFsm *pt=const_cast<WfsFsm *>(this);
   ret =  pt->AbstractFsm::processCommand();

   if(ret)
      _logger->log(Logger::LOG_LEV_DEBUG,"processCommand() retured TRUE (success)");
   else
       _logger->log(Logger::LOG_LEV_DEBUG,"processCommand() retured FALSE (failure)");
   return ret;
}




