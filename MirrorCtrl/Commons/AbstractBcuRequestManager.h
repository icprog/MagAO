#ifndef ABSTRACT_BCU_REQUEST_MANAGER_H_INCLUDED
#define ABSTRACT_BCU_REQUEST_MANAGER_H_INCLUDED

#include <list>
#include <vector>
#include <string>
using namespace std;

extern "C"{
	#include "base/thrdlib.h"
}

#include "BcuRequest.h"
#include "BcuRequestInfo.h"
#include "BcuPacket.h"
#include "BcuPacketQueue.h"
#include "MirrorCtrlExceptions.h"


/* 
 * Abstract class to handle a BCU Request.
 *
 * Possible Bcu Requests are:
 *  - Bcu Command, received from MsgD inside a MsgBuf
 *  - Diagnostic Request, generated by Diagnostic Manager
 *
 * This class must be extended by a "Bcu Request Producer" (at the moment a BcuCommandHandler,
 * a DiagnosticManager or a Watchdog.)
 * 
 * Each AbstractBcuRequestManager can ba attached to a set of BCUs with contiguous IDs (see 
 * BcuCommon for the available IDs), starting from a certain ID. Each ID is mapped to an 
 * BcuPacketQueue to send out packets.
 * Therefore an AbstractBcuRequestManager has a pool of BcuPacketQueue to send BcuPackets to
 * different BCUs; is possible to obtain one of these queue calling getOutputQueue(int bcuId).
 * To really send the BcuPackets each output-queue must be added to the desired
 * BcuCommunicator (using BcuCommunicator.addInputQueue(*output-queue)).
 * 
 * The tipical implementation of an AbstractBcuRequestManager must perform the following calls :
 * 
 *  1. initBcuPool(int bcuStart, int bcuNum);
 * 	2. setBcuRequestInfo(BcuRequest* request)
 * 	3. sendBcuRequest(BcuRequest* request)
 * 	4. waitBcuReply(int timeout_ms = NULL)		
 * 	5. -> handle the bcu reply in some way, if needed		
 *  6. clearBcuRequestInfo()
 * 
 * taking care of catching all the defined exceptions in this order: 
 * 	- TimeoutExpiredException
 *  - MirrorControllerShutdownException
 *  - AbstractBcuRequestManagerException
 */
class AbstractBcuRequestManager {
    
	public:		//--- METHODS
    
        /*
         * Create the object:
         * 	- Retrieve the logger
         *  - Init some other fields
         */
        explicit AbstractBcuRequestManager(string concreteClassName, int id, int priority, int logLevel);
        
        // Destroy the object
        virtual ~AbstractBcuRequestManager();
        
        // Get the BcuPacket output-queue corresponding to a
        // certain Bcu
        BcuPacketQueue* getOutputQueue(int bcuId);    
        
        // Returns some info to identify the objects instances
    	const string getObjId() { return _objId; }
        const string getClassName() { return _concreteClassName; }
        
        const int getBcuNum()   { return _bcuNum; }
        const int getBcuStart() { return _bcuStart; }
        
        Logger* getLogger() { return _logger; }
       
        
    protected: 	// --- METHODS
    
    	/*
    	 * (0) This must be called by the derived class constructor (if possible)
    	 * or before using sendBcuRequest() (otherwise it will throw an 
    	 * AbstractBcuRequestManagerException)
    	 */
    	void initBcuPool(int bcuStart, int bcuNum);
    
    	/*
    	 * (1) 
    	 * Initialize the current request info.
    	 */
        void setBcuRequestInfo(BcuRequest* request, BYTE* dataAddress = NULL) throw(InvalidSharedMemoryException);

    	/*
    	 * (2)
    	 * Unpacks the request in a set of BcuPackets and sends them (actually insert
    	 * them in the output queues)
    	 */
        void sendBcuRequest() throw(AbstractBcuRequestManagerException, MirrorControllerShutdownException);
        
        /*
         * (3)
         * Waits indefinitively for the reply.
         * In case the reply is not requested, waits for packets succesfully sent
         * and cleared, to guarantee that "data" referenced from each packet are
         * not cleaned by the client
         * ATTENTION: the reply will always be completed by the BcuComunicator, reporting a success
         * or a failure.
         */
        void waitBcuReply() throw (MirrorControllerShutdownException);
        
        /*
         * (4)
         * Clear the RequestManager after a request have been handled or aborted.
         * Remeber to call this before exiting the "requester thread" !!!
         */
        void clearBcuRequestInfo() {
        	if(_currentRequestInfo != NULL) {
        		_logger->log(Logger::LOG_LEV_DEBUG, "Clearing BcuRequestInfo for %s [ID:%s]", getClassName().c_str(), getObjId().c_str());
				_currentRequestInfo->clear();
			}
        }
        
        
    protected: // --- FIELDS (protected only for tests)
    
    	bool _bcuPoolInitialized;
    
        // First BCU attached and number of BCUs
        int _bcuStart;
        int _bcuNum;
        
        // Priority
        int _priority;
    
        // Info about the current Bcu Request: used to wait for
        // the reply and handle it 
        BcuRequestInfo* _currentRequestInfo;   
        
        // Pool of thread-safe queues for the outgoing BcuPackets
        // to differents BCUs
        // The size of the pool depends on _bcuNum
        vector<BcuPacketQueue*> _outputQueuePool;
       
       	 // A reference to its own logger
        Logger* _logger;
        
     private:
     
     	// Some info about the concrete class/object instantiated
    	string _concreteClassName;
    	string _objId;	// [FirstBcu]_[Priority]
    	
    	/*
    	 * Send "reqPacketSize" of a BcuRequest, using a shmBuffer as source/destination (WRITE/READ)
    	 * of data, handling multiple BCUs and DSP.
    	 */
    	void handleMultiDspAndBcu(BcuRequest* request, int reqPacketSize, BYTE* shmBuffer, int bcuDataSize, uint* madePackets) throw(AbstractBcuRequestManagerException);
    
};

#endif
