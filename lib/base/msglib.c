//
// @File: msglib.c
//
// Message management library
//
// This file contains utilities to manage message exchange among
// the LBT-AO components.
//
// \msgl\  API is directly used by LBT-AO components to manage message exchange,
// and by services from other libraries, e.g.: \rtdbl\  and \bufl.
//
// The list of currently defined messages can be found in file
// @see{msglib.h}.
//
// \subsection*{Notes}
//
// Most functions in \msgl\  use an {\tt msgbuf} structure to hold messages.
// Such a structure must be previously allocated and initialized by calling
// @see{InitMsgBuf}. 

// Such a structure may be used many times for different messages, but
// because  intialization also allocates memory from the heap, the structure 
// must be explicitly destroyed by calling @see{FreeMsgBuf} when it is not
// used any more.
//@

#include <stdlib.h>
#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>

#include <unistd.h> 
#include <netdb.h> 
#include <fcntl.h> 
#include <sys/types.h> 
#include <sys/time.h> 
#include <time.h> 
#include <sys/socket.h>
#include <netinet/in.h> 
#include <arpa/inet.h> 

#include <netinet/tcp.h>


#include "base/msglib.h"
#include "base/errlib.h"


Connection theServer = { (-1),{0,0,{0},{0}}, "" };

static MsgBuf auxmsgb = MSGB_ZERO; // Utility msg buffer

static int VersMaj=0;
static int VersMin=0;
static int VersthMode=0;

static int msgDebug=0;

static int seqSeed=0;
static int seqOfst=0;

static int bufTag=0;

static int logSeqNum=(-1);

void setSeed(int seed)
{
seqOfst=seed;
}

static char *logDescrTable[] = {
      "UNK", "DIS",                  // Stub to be removed
      MASTER_LOG_SYM_ALWAYS,
      MASTER_LOG_SYM_FATAL,
      MASTER_LOG_SYM_ERROR,
      MASTER_LOG_SYM_WARNING,
      MASTER_LOG_SYM_INFO,
      MASTER_LOG_SYM_DEBUG,
      MASTER_LOG_SYM_TRACE,
      MASTER_LOG_SYM_VTRACE,
};

static int MasterLogTableMax = (sizeof(logDescrTable)/sizeof(char *))-1;


static int newLogSeqN(void)
{
  logSeqNum += 1;
  if(logSeqNum>1000000000) logSeqNum=0;
  return logSeqNum;
}

//@Function{API}: timeString

// returns a properly formatted string representing time

// This function returns  a string representig time in a proper format.
// The main use of this procedure is to unify the format of log files
// generated by applications.
//@

void timeString(struct timeval *tv, //@P{tv}: Time value (as returned, by gettimeofday())
                                    // If NULL gettimeofday() is called.
               char        *result) //@P{result}: returned string. result must be a pointer
                                    // to a charcter string at least  27 character long
                                    // (including trailing NUL) allocated by the caller
{
  struct timeval mytv;
  struct tm lt;
  time_t tt;

  if(!tv) {
    gettimeofday(&mytv,NULL);
    tv=&mytv;
  }
  tt=tv->tv_sec;

  localtime_r(&tt,&lt);

  sprintf(result, "%4.4d-%2.2d-%2.2d %2.2d:%2.2d:%2.2d.%06d", 
               lt.tm_year+1900,lt.tm_mon+1,lt.tm_mday,
               lt.tm_hour,lt.tm_min,lt.tm_sec,(int)tv->tv_usec);
}

//Function{API}: logDescr
//
// Returns log level description 
//
// This function returns a pointer to a three character long description
// of log level, given the numerical log level.
//

char *logDescr(int level) //@P{level}: numerical log level, values are:
                          // MASTER_LOG_LEV_VTRACE,
                          // MASTER_LOG_LEV_TRACE, MASTER_LOG_LEV_DEBUG,
                          // MASTER_LOG_LEV_INFO, MASTER_LOG_LEV_WARNING,
                          // MASTER_LOG_LEV_ERROR, MASTER_LOG_LEV_FATAL,
{
if(level<0) level=0;
if(level>MasterLogTableMax) level=MasterLogTableMax;
return logDescrTable[level];
}

//Function{API}: logNumLevel
//
// Returns log level numerical value 
//
// This function returns the numerical log level, 
// given a pointer to the three character long description
// of log level.
//

int logNumLevel(const char* descr) //@P{descr} description of log level, values are:
		                           // MASTER_LOG_SYM_TRACE, MASTER_LOG_SYM_DEBUG,
		                           // MASTER_LOG_SYM_INFO, MASTER_LOG_SYM_WARNING,
		                           // MASTER_LOG_SYM_ERROR, MASTER_LOG_SYM_FATAL,
		                           // MASTER_LOG_SYM_DISABLED, MASTER_LOG_SYM_ALWAYS
		                           // MASTER_LOG_SYM_UNKNOWN
                          
{
    if (strncmp(descr, MASTER_LOG_SYM_VTRACE, 3) == 0) return MASTER_LOG_LEV_VTRACE;
    if (strncmp(descr, MASTER_LOG_SYM_TRACE, 3) == 0) return MASTER_LOG_LEV_TRACE;
    if (strncmp(descr, MASTER_LOG_SYM_DEBUG, 3) == 0) return MASTER_LOG_LEV_DEBUG;
    if (strncmp(descr, MASTER_LOG_SYM_INFO, 3) == 0) return MASTER_LOG_LEV_INFO;
    if (strncmp(descr, MASTER_LOG_SYM_WARNING, 3) == 0) return MASTER_LOG_LEV_WARNING;
    if (strncmp(descr, MASTER_LOG_SYM_ERROR, 3) == 0) return MASTER_LOG_LEV_ERROR;
    if (strncmp(descr, MASTER_LOG_SYM_FATAL, 3) == 0) return MASTER_LOG_LEV_FATAL;
    return -1;
}

//Function: nlogString
//
// Return a properly formatted log string

void nlogString(const char  *procName,
                int    level,
                int    seqn,         // Sequence number
                struct timeval *tv,
                char *result)
{
  char *lvdescr=logDescr(level);
  char ttxt[30];

  timeString(tv,ttxt);
  snprintf(result,MASTER_LOG_HEADER_LEN,MASTER_LOG_HEADER,
           procName,lvdescr,seqn,ttxt);
}



//Function{API}: logString
//
// Return a properly formatted log string

int logString(const char *procName, //@P{procName}: Process name
              int    level,         //@P{level}: Level code. One of:
              struct timeval *tv,   //@P{tv}: Time (as returned by gettimeofday())
                                    // If NULL current time is used
              char *result)         //@P{result}: Buffer for returned string.
                                    // Length is at least MASTER_LOG_HEADER_LEN
                                    // (Including trailing NUL)
                                    // @R: Log record sequence number. Can be used to allow
                                    // correlation between different log streams
{
  int seqn=newLogSeqN();
  nlogString(procName,level,seqn,tv,result);
  return seqn;
}



//@Function{API}: NewSeqN

// Generate e new unique sequence number

// This function generates a new sequence number which is guaranteed to 
// be unique (No other \msgd\  client will ever generate the same number).
// Within the same client, sequence numbers generated by this function
// will cycle with a period of 65536.
//@

int NewSeqN(void)
{
   seqSeed=(seqSeed+1)&0xffff;
   return(seqSeed+seqOfst);
}

//@Procedure{API}: ReverseHeader  

// Swaps From and To fields in a MsgBuf structure
//
// This routine can be called to swap the From (sender) field with the
// To (destination) field, e.g. to easily create an header suitable
// to reply to the sender.
//@

void ReverseHeader(MsgBuf *msgb)    // @P{msgb}: MsgBuf structure pointer
                                    // Only the From and To fields of the 
                                    // structure are affected.
{
    char aux[PROC_NAME_LEN];

    strncpy(aux,HDR_TO(msgb),PROC_NAME_LEN);
    strncpy(HDR_TO(msgb),HDR_FROM(msgb),PROC_NAME_LEN);
    strncpy(HDR_FROM(msgb),aux,PROC_NAME_LEN);

}

//@Procedure: StrHeader

// Return a printable version of message header (for debug purposes)

// This routines writes into a user supplied string a printable version
// of the message header, properly formatted for debug purposes.
//
// Il the character buffer is shorther than needed, the string is truncated.
// 

//@

char *StrHeader(MsgBuf* msgb,  //@P{msgb}: Message buffer pointer
               char   buf[],   //@P{buf}: Character buffer. It must be at least "bufl" characters long
               int    bufl)    //@P{ret}:  Length of character buffer. Actual string length
                               // May vary, a total length of 140 bytes should be suitable
                               // @R: pointer to input buffer
{

snprintf(buf,bufl,"From:\"%s\" To:\"%s\" Code:%6.6x pLoad:%d Flags:%2.2x SeqN:%d Len:%d TTL:%d",
         HDR_FROM(msgb),HDR_TO(msgb), HDR_CODE(msgb),HDR_PLOAD(msgb),
         HDR_FLAGS(msgb),HDR_SEQN(msgb),HDR_LEN(msgb),HDR_TTL(msgb));
return buf;
}

//@Procedure: StrHeaderE

// Return a printable version of message header (extended version)

// This routines writes into a user supplied string a printable version
// of the message header, properly formatted for debug purposes.
//
// Il the character buffer is shorther than needed, the string is truncated.
// 

//@

char *StrHeaderE(MsgBuf* msgb,  //@P{msgb}: Message buffer pointer
                 char *  srcd,  //@P{srcd}: Source Domain (may be "")
                 char *  dstd,  //@P{dstd}: Destination Domain (may be "")
                 char   buf[],  //@P{buf}: Character buffer. It must be at least "bufl" characters long
                 int    bufl)   //@P{ret}:  Length of character buffer. Actual string length
                               // May vary, a total length of 140 bytes should be suitable
                               // @R: pointer to input buffer
{
   char srcdbuf[PROC_NAME_LEN+1];
   char dstdbuf[PROC_NAME_LEN+1];
   mkFullName( HDR_FROM(msgb), srcd,srcdbuf);
   mkFullName( HDR_TO(msgb), dstd,dstdbuf);

snprintf(buf,bufl,"From:\"%s\" To:\"%s\" Code:%6.6x pLoad:%d Flags:%2.2x SeqN:%d Len:%d TTL:%d",
         srcdbuf, dstdbuf, HDR_CODE(msgb),HDR_PLOAD(msgb),
         HDR_FLAGS(msgb),HDR_SEQN(msgb),HDR_LEN(msgb),HDR_TTL(msgb));
return buf;
}


//@Procedure: HexHeader

// Return an hexadecimal version of message header (for debug purposes)

// This routines writes into a user supplied string a printable version
// of the message header, properly formatted for debug purposes.
//
// Il the character buffer is shorther than needed, the string is truncated.

//@

char *HexHeader(MsgBuf* msgb,  //@P{msgb}: Message buffer pointer
               char   buf[],   //@P{buf}: Character buffer. It must be at least "bufl" characters long
               int    bufl)    //@P{ret}:  Length of character buffer. Actual string length
                               // may vary, a total length of 450 bytes should be suitable
                               // @R: pointer to input buffer
{
int n=sizeof(Message),i,rest=bufl;
unsigned char * in=(unsigned char *)&(msgb->Msg->SG);
char *dst=buf;

for(i=0;i<n;i++) {
   char aux[6];
   sprintf(aux,"%2.2x ",*in++);
   if(rest<4) break;
   strncpy(dst,aux,3);
   dst+=3; rest-=3;
}
*dst='\0';
return buf;
}




//@Procedure: PrintHeader

// Print message header to stderr (for debug purposes)

// This routines prints onto stdout the content of the
// message header, properly formatted for debug purposes.

//@

void PrintHeader(MsgBuf* msgb,     //@P{msgb}: Message buffer pointer
                 const char* pref, //@P{pref}: String prepended to output message
                 int     ret)      //@P{ret}:  Error return from send/recv routine
{
char buf[140];

fprintf(stderr,"%s %s Errcod:%d\n",pref,StrHeader(msgb, buf,140),ret);
}


// @Function{API}: SetMsgLength 

// Sets the Message Length field of a Message
//
// This routine writes an assigned message length in the proper field
// of a MsgBuf structure. The availabkle buffer space is also checked
// and possibly extended by calling ResizeMsgBuf().
// The other fields of the structure remain unaffected.
//@

int SetMsgLength(int    len,        // @P{len}: Message Length
	         MsgBuf *msgb)      // @P{msgb}: Message structure
                                    // @R: completion code
{
    int stat;

    if(len<0 || len>MAX_MSG_LEN) 
	return PLAIN_ERROR(MSG_LEN_ERROR);
    
    if(IS_NOT_ERROR(stat=ResizeMsgBuf(msgb, len)))
        HDR_LEN(msgb) = (unsigned)len;

    return stat;
}


// @Function{API}: SetSeqNum

// Sets the Sequence number field of a Message
//
// This routine writes an assigned sequence number in the proper field
// of a MsgBuf structure. 
// The other fields of the structure remain unaffected.

// Note: the function @see{NewSeqN} may be used to generate unique
//       sequence numbers.
//@

int SetSeqNum(int SeqNum,        // @P{SeqNum}: Sequence number
	      MsgBuf *msgb)      // @P{msgb}: Message structure
                                 // @R: completion code
{
    HDR_SEQN(msgb) = (unsigned)SeqNum;
    return NO_ERROR;
}

// @Procedure{API}: SetFlag

// Sets the flag in the message code
//
// This routine sets the specified flag in the message code. The message
// flags only affect communication managed by the services in thrdlib;
// flags have no effect whatsoever on applications which are not
// based on thrdlib services.

// The message code can be marked with either the NOHANDLE\_FLAG or
// the DISCARD\_FLAG.

// If the NOHANDLE\_FLAG is set in the message code then the message sent
// in reply will be forcefully put into the message queue, ignoring
// possible handler.

// If the DISCARD\_FLAG is set in the message code, then the message sent
// in reply will be dropped by the message queue manager.

//@

int SetFlag(int     flag,     // @P{flag}: either NOHANDLE_FLAG or DISCARD_FLAG or 0
            MsgBuf *msgb)     // @P{msgb}: Message structure
                              // @R: completion code
{
    int stat=NO_ERROR;

    HDR_FLAGS(msgb) = 0;
    switch(flag) {
        case 0: break;
        case NOHANDLE_FLAG:
             HDR_FLAGS(msgb) |= NOHANDLE_FLAG;
             break;
        case DISCARD_FLAG:
             HDR_FLAGS(msgb) |= DISCARD_FLAG;
             break;
        default:
             stat=MSG_FLAG_ERROR;
    }
    return stat;
}


// @Function{API}: SetMsgTTL

// Set Time to live for a specific message
//
// This routine sets the value of message Time to Live (TTL)
// TTL values are used by thrdlib based applications in order to
// remove expired messages from the message queue. 
//
// In order to cope with specific needs the assigned value can be
// modified with a call to this routine for each individual message.
//
//@

int SetMsgTTL(int     ttl,     // @P{ttl}: Message Time to Live (sec).
                               //  If set to 0, the default client value
                               //  will be used.
              MsgBuf *msgb)    // @P{msgb}: Message structure
                               // @R: completion code
{
   if(ttl<0) ttl=0;
   HDR_TTL(msgb)=ttl;
   return NO_ERROR;
}


// @Function{API}: SetMsgDest 

// Sets the Message Destination field of a Message

// This routine writes an assigned destination in the proper field
// of a Message structure. The other fields of the structure remain
// unaffected.
//@

int SetMsgDest(const char *To,  // @P{To}: Message destination code
               MsgBuf *msgb)    // @P{msgb}: Message structure
                                // @R: completion code
{
    strncpy(HDR_TO(msgb),To,PROC_NAME_LEN);
    HDR_TO(msgb)[PROC_NAME_LEN]='\0';

    return(NO_ERROR);
}

// @Function{API}: SetMsgSender 

// Sets the Message Sender field of a Message

// This routine writes an assigned sender in the proper field
// of a Message structure. The other fields of the structure remain
// unaffected.
//@

int SetMsgSender(const char *From, // @P{From}: Message sender
	         MsgBuf *msgb)     // @P{msgb}: Message structure
                                   // @R: completion code
{
    strncpy(HDR_FROM(msgb),From,PROC_NAME_LEN);
    HDR_FROM(msgb)[PROC_NAME_LEN]='\0';

    return(NO_ERROR);
}

// @Function{API}: SetMsgCode 

// Sets the Message Code field of a Message
//
// This routine writes an assigned message code in the proper field
// of a Message structure. The other fields of the structure remain
// unaffected.
//@

int SetMsgCode(int    MsgC,     // @P{MsgC}: Message code
	       MsgBuf *msgb)    // @P{msgb}: Message structure
                                // @R: completion code
{
    HDR_CODE(msgb)=(unsigned)MsgC;
    return NO_ERROR;
}


// @Function{API}: SetMsgPload 

// Sets the Payload field of a Message
//
// This routine writes an assigned integer value in the proper field
// of a Message structure. The other fields of the structure remain
// unaffected.
//@

int SetMsgPload(int   pLoad,     // @P{pLoad}: Message code
	       MsgBuf *msgb)      // @P{msgb}: Message structure
                                  // @R: completion code
{
    HDR_PLOAD(msgb)=pLoad;
    return NO_ERROR;
}


// @Function{API}: InitMsgBuf 

// Initialize a message buffer structure
//
// This routine creates a MsgBuf structure allocating the required resources
//
// The memory buffer allocated can be preset to a given message body length
// but it can be resized for longer messages with a call to ResizeMessage(). 
// When the buffer is used to receive messages it is resized as needed
// automatically.
//
// The resources allocated for the structure can be freed with a call to
//  FreeMsgBuf().
//@

int InitMsgBuf(MsgBuf *msgb,  // @P{msgb}: Pointer to Message structure
               int      len)  // Initial message body length. If zero
                              // only the space for a message header
                              // is allocated
                              // @R: completion status
{
    int blen;
    if(len<0) len=0;

    blen=sizeof(Message)+len;

    MSG_BUFFER(msgb)=malloc(blen);
    if(MSG_BUFFER(msgb)==NULL) 
       return SYSTEM_ERROR(MEMORY_ALLOC_ERROR);
    msgb->buflen=blen;
    msgb->next=NULL;
    msgb->bId=bufTag++;

    /* if(msgDebug) printf("DBG> InitMsgBuf allocated %d bytes (#%d:%lX)\n",
                                                 blen,msgb->bId,(unsigned long)MSG_BUFFER(msgb)); */
    HDR_MAGIC(msgb)=MSG_HEADER_MAGIC;
    HDR_PLOAD(msgb)=0;
    HDR_LEN(msgb)=0;
    HDR_FLAGS(msgb)=0;
    HDR_TTL(msgb)=0;       // This field used by thrdlib only
    return NO_ERROR;
}

// @Function{API}: ResizeMsgBuf 

// Modify (extend) the size of a message buffer structure
//
// This routine resizes a MsgBuf structure allocating the resources as 
// required. The structure must be initialized by calling InitMsgBuf().
//
// Note 1: if the requested size is smaller than the current MsgBuf structure
// size, the call has no effect.
//
// Note 2: When the MsgBuf structure is used to receive messages it is 
// resized automatically as needed.
//@


int ResizeMsgBuf(MsgBuf *msgb,   // @P{msgb}: MsgBuf structure
                 int       len)   // Required message body length
                                  // @R: completion code
{
    size_t reqlen=len+sizeof(Message);
    if(msgb->buflen>=reqlen) 
       return NO_ERROR;

    /*
    if(msgDebug) {
       unsigned long auxadr=(unsigned long)MSG_BUFFER(msgb);
       printf("DBG> ResizeMsgBuf realloc %d bytes (#%d:%lX)\n",reqlen,msgb->bId,auxadr);
    }
    */
    MSG_BUFFER(msgb)=realloc(MSG_BUFFER(msgb),reqlen);
    if(MSG_BUFFER(msgb)==NULL) return SYSTEM_ERROR(MEMORY_ALLOC_ERROR);
    msgb->buflen=reqlen;

    return NO_ERROR;
}

// @Function{API}: FreeMsgBuf 
//
// Deallocate resources for a message buffer structure
//
// This routine deallocates the resources used for a MsgBuf structure
// which is no longer in use. The MsgBuf structure must be initialized
// by a call to InitMsgBuf() prior of any other operation.
//
//@

int FreeMsgBuf(MsgBuf *msgb)    // @P{msgb}: MsgBuf structure
                                // @R: completion code
{
    if(msgb->buflen>0) {
       /* if(msgDebug) printf("DBG> FreeMsgBuf freed %d bytes (#%d:%lX)\n",
                            msgb->buflen,msgb->bId,(unsigned long)MSG_BUFFER(msgb)); */
       free(MSG_BUFFER(msgb));
}

    MSG_BUFFER(msgb)=NULL;
    msgb->buflen=0;

    return NO_ERROR;
}

// @Function{API}: ZeroMsgBuf 

// Set the entire message buffer (header and body) to zero
//
// This routine cleans the message buffer (set to zero)
//
//@

int ZeroMsgBuf(MsgBuf *msgb)  // @P{msgb}: Pointer to Message structure
                              // @R: completion status
{
    if(msgb->buflen>0)
       memset(MSG_BUFFER(msgb),0,msgb->buflen);

    // if(msgDebug) printf("ZeroMsgBuf zeroed %d bytes (#%d:%lX)\n",msgb->buflen,msgb->bId,(unsigned long)MSG_BUFFER(msgb));
    return NO_ERROR;
}

// @Function{API}: FillHeader 
//
// Fills data into the Header of a Message
//
// This routine initializes the header portion of a message structure 
// filling fields from arguments.
//@


int FillHeader(int MsgLen,         // @P{MsgLen}: Message body length
              int SeqNum,         // @P{SeqNum}: Sequence number
              const char *Sender, // @P{Sender}: Sender identifier. 
                                   //   If NULL the field is not modified
              const char *Dest,   // @P{Dest}: Destination identifier. 
                                   //   If NULL the field is not modified
              int   MsgC,         // @P{MsgC}: Message code
              MsgBuf *msgb)       // @P{msgb}: MsgBuf structure
                                   // @R: completion code
{
    HDR_LEN(msgb)=(unsigned)MsgLen;
    HDR_SEQN(msgb)=(unsigned)SeqNum;
    if (Sender)  {
        strncpy(HDR_FROM(msgb),Sender,PROC_NAME_LEN);
        HDR_FROM(msgb)[PROC_NAME_LEN]='\0';
    } 

    if (Dest)  {
        strncpy(HDR_TO(msgb),Dest,PROC_NAME_LEN);
        HDR_TO(msgb)[PROC_NAME_LEN]='\0';
    }

    HDR_CODE(msgb)=(unsigned)MsgC;

    return NO_ERROR;
}


// @Function{API}: FillBody 

// Fills data into the Body of a Message
//
// This routine writes data into the body portion of a MsgBuf structure 
// The Len field of the header is modifyed accordingly.
//
// Note: the routine also checks that the MsgBuf structure size is suitable
//       for the message length specified. If less than that it resizes
//       the message buffer by calling ResizeMsgBuf().
//@

int FillBody(const void *data,     // @P{data}: Pointer to data buffer
                   int len,        // @P{len}: Length of data buffer (in bytes)
                   MsgBuf *msgb)   // @P{msgb}: MsgBuf structure
{
    int stat;

    if(IS_ERROR(stat=SetMsgLength(len, msgb)))
       return stat;

    memcpy(MSG_BODY(msgb),(unsigned char*)data,len);

    return NO_ERROR;
}

// @Function{API}: FillMessage 

// Fills data into the a message buffer
//
// This routine writes data  into a message buffer filling fields 
// from arguments. A call to this routine is equivalento to calling
// in sequence FillHeader() and FillBody()
//
// Note: the routine also checks that the message structure size is suitable
//       for the message body length specified. If less than that it resizes
//       the message buffer by calling ResizeMsgBuf().
//@

int FillMessage(int MsgLen,         // @P{MsgLen}: Message body length (bytes)
                int SeqNum,         // @P{SeqNum}: Sequence number
                const char *Sender, // @P{Sender}: Sender identifier
                const char *Dest,   // @P{Dest}: Destination identifier
                int  MsgC,          // @P{MsgC}: Message code
                const void *Data,   // @P{Data}: Data to write into message body
                MsgBuf *msgb)       // @P{msgb}: MsgBuf structure
                                    // @R: completion code
{
   FillHeader(MsgLen,SeqNum,Sender,Dest,MsgC,msgb);
   return FillBody(Data,MsgLen,msgb);
}




// @Function: SendToSK

// Send a message to a destination specified as socket descriptor
//
// This routine sends a full message to another process identified with
// its socket descriptor. 
//@

int SendToSK(int socketfd,    // Recipients socket descriptor
             MsgBuf  *msgb)   // @P{msgb}: MsgBuf structure
                              // @R: Completion code
{
    int stat,sent,msglen;

    Message *m=MSG_BUFFER(msgb);

    stat=NO_ERROR;
    msglen=sizeof(Message)+HDR_LEN(msgb);
            // Send full message (header+body)
            //
            // Note: The message must be sent in a single call to avoid
            //       long delays due to TCP/IP optimization algorithm
            //
    if((sent=send(socketfd,m,msglen,MSG_NOSIGNAL))!=msglen) {
       if(sent == -1)
	       stat = SYSTEM_ERROR(CLOSEDCONN_ERROR);
       else 
          stat = SYSTEM_ERROR(COMMUNICATION_ERROR);
    } 
    return(stat);
}



// @Function{API}: WaitMessage 

// Waits for a message sent by a correspondant or returned by MsgD-RTDB
//
// This routine waits for a message sent by the correspondant.
// A message is made up of an header optionally followed by a message
// body. The caller must check the MsgLen field of the header before
// using the content of the message buffer.
//
// See the notes about the message structure in routine WaitMsgFromServer().
//@

int WaitMessage(int socketfd,          // Socket file descriptor
               MsgBuf *msgb)           // @P{msgb}: MsgBuf structure to receive 
                                       // message data
                                       // The Message structure must be 
                                       // properly initialized 
                                       // (see InitMsgBuf())
{
   extern int errno;

   int stat,len,errno_cp;
   size_t msglen;
   void *buf;

   len = sizeof(Signature);
   buf = MSG_BUFFER(msgb);
   msgb->hd_ok=0;
   stat = recv(socketfd,buf,len,MSG_WAITALL);     // read message signature
   if (stat == 0)
      return FATAL_ERROR(CLOSEDCONN_ERROR);
   else if (stat!=len) {
      errno_cp=errno;
      return SYSTEM_ERROR(COMMUNICATION_ERROR);
   } 

   if((HDR_MAGIC(msgb)!=MSG_HEADER_MAGIC) && (HDR_MAGIC(msgb)!=43)) // Protocol version mismatch
      return SYSTEM_ERROR(VERSION_MISMATCH_ERROR);

   if((msglen=HDR_LEN(msgb))>0) {      // Check for message body
      size_t totlen= msglen + sizeof(Message);
      if(totlen>msgb->buflen) {       // Message buffer lenght
                                      // is adjusted dynamically
         MSG_BUFFER(msgb)=realloc(MSG_BUFFER(msgb),totlen);
         if(MSG_BUFFER(msgb)==NULL) {
            msgb->buflen=0;
            return SYSTEM_ERROR(MEMORY_ALLOC_ERROR);
         }
         msgb->buflen=totlen;
      }
   }
   buf = (void *)MSG_HEADER(msgb);
   if(HDR_MAGIC(msgb) == MSG_HEADER_MAGIC) {  // Protocol version OK
                                              // Read remaing header+msg
      len = msglen+sizeof(Header);
      while (len>0) {
         stat = recv(socketfd,buf,len,MSG_WAITALL); 
         if (stat == 0) 
            return FATAL_ERROR(CLOSEDCONN_ERROR);
         else if (stat<0) {
            errno_cp = errno;
            if ((errno_cp==EAGAIN)||(errno_cp==EINTR)) continue;
            return SYSTEM_ERROR(COMMUNICATION_ERROR);
         } else {
            buf = buf+stat;
            len = len-stat;
         }
      }
      msgb->hd_ok=1;
   } else {    // Manage protocol version 43
      Header43 hdr43;
      len=sizeof(Header43);
      buf=&hdr43;
      while (len>0) {                    // Read old style header
         stat = recv(socketfd,buf,len,MSG_WAITALL); 
         if (stat == 0) 
            return FATAL_ERROR(CLOSEDCONN_ERROR);
         else if (stat<0) {
            errno_cp = errno;
            if ((errno_cp==EAGAIN)||(errno_cp==EINTR)) continue;
            return SYSTEM_ERROR(COMMUNICATION_ERROR);
         } else {
            buf = buf+stat;
            len = len-stat;
         }
      }
      if(msglen>0) {                 // Read message body, if any
         len=msglen;
         buf=MSG_BODY(msgb);
         while (len>0) {                    // Read old style header
            stat = recv(socketfd,buf,len,MSG_WAITALL); 
            if (stat == 0) 
               return FATAL_ERROR(CLOSEDCONN_ERROR);
            else if (stat<0) {
               errno_cp = errno;
               if ((errno_cp==EAGAIN)||(errno_cp==EINTR)) continue;
               return SYSTEM_ERROR(COMMUNICATION_ERROR);
            } else {
               buf = buf+stat;
               len = len-stat;
            }
         }
      }
      strncpy(HDR_FROM(msgb),hdr43.From,PROC_NAME_LEN);  // Move From field
      HDR_FROM(msgb)[PROC_NAME_LEN]='\0';
      strncpy(HDR_TO(msgb),hdr43.To,PROC_NAME_LEN);      // Move Dest field
      HDR_TO(msgb)[PROC_NAME_LEN]='\0';
      HDR_SEQN(msgb)=hdr43.SeqNum;
      HDR_CODE(msgb)=hdr43.Code;
      HDR_PLOAD(msgb)=hdr43.pLoad;
      HDR_FLAGS(msgb)=hdr43.Flags;
      HDR_TTL(msgb)=hdr43.ttl;
   } 

   return(NO_ERROR);
}

//@Function: NormalizeIP
//
// Returns a normalized IP address
//
// This routine converts an input IP address into a normalized form.
// If a pointer to sockaddr_in structrure is not NULL, the structure is
// initialized with IP/Port data.
//
// The input address has the form: a.b.c.d[:ppp] where a.b.c.d is an IP
// address in numeric form and ppp an optional port number.
// The following forms are accepted:
//
//    "a.b.c.d"     - equivalent to: a.b.c.d:default
//    "p"           - equivalent to: 127.0.0.1:p
//    ""            - equivalent to: 127.0.0.1:default
//
//  The default port number is derived as follows:
//
//  1. From environment variable MSGD_PORT
//  2. if MSGD_PORT is not defined the value 9752 is used
//
// The normalized IP addres is stored back in the input buffer
//@

int NormalizeIP(char *ip,                  //@P{ip}: Buffer for IP value. Normalized value
                                           //        stored here, so the buffer must provide
                                           //        enough space (at least 22 bytes).
                int  lng,                  //@P{lng}: buffer length
                struct sockaddr_in *saddr) //@P{saddr}: Pointer to sockaddr_in
                                           //           structure (may be NULL)
{
char ip_addr[50];
char *pt0, *pt1;
int size=sizeof(ip_addr);
int l,stat=NO_ERROR;
int aport=(-1);
int n[4] = {(-1),(-1),(-1),(-1)};

for(l=0;l<size;l++) ip_addr[l]='\0';

l=snprintf(ip_addr,size,"%s",ip);
if(l>=size) stat=TRUNCATE_ERROR;

pt0=index(ip_addr,':');
if(pt0) {
   sscanf(pt0+1,"%d",&aport);
   *pt0='\0';
} 

pt0=index(ip_addr,'.');
if(!pt0) {
   sscanf(ip_addr,"%d",&aport);
   strcpy(ip_addr,"127.0.0.1");
}

for(l=0,pt0=ip_addr,pt1=ip_addr;l<3;l++) {
   pt1=index(pt0,'.');
   if(!pt1) break;
   *pt1='\0';
   sscanf(pt0,"%d",&n[l]);
   pt0=pt1+1;
}
sscanf(pt0,"%d",&n[3]);

if(n[0]<1 || n[1]<0 || n[2]<0 || n[3]<1 ||
   n[0]>254 || n[1]>254 || n[2]>254 || n[3]>254)  {
    n[0]=127;
    n[1]=0;
    n[2]=0;
    n[3]=1;
    stat=SYNTAX_ERROR;
}
    
if(aport<0) {
   pt0=getenv("MSGD_PORT");    // Search port number in Environment
   if(pt0) sscanf(pt0,"%d",&aport);
}
if(aport<0) aport=MSGD_PORT;

if(aport>65535) stat=SYNTAX_ERROR;

l=snprintf(ip,lng,"%d.%d.%d.%d:%d",n[0],n[1],n[2],n[3],aport);
if(l>=lng) stat=TRUNCATE_ERROR;

if(saddr) {
   snprintf(ip_addr,50,"%d.%d.%d.%d",n[0],n[1],n[2],n[3]);
   saddr->sin_family = AF_INET;             
   saddr->sin_port = htons(aport); 
   inet_pton(AF_INET,ip_addr,&(saddr->sin_addr));
   memset(&(saddr->sin_zero), '\0', 8); // zero the rest of the struct 
}
return stat;
}

// @Function: ConnectInit 

// Opens a connection to any server
//
// This routine opens a bidirectional client connection to 
// a server.
//
// It is intended to be used exclusively as internal routine to this 
// library or by the MsgD-RTDB. 
//
//@

int ConnectInit(Connection *tserv) // Pointer to server connection data. it must point
                                   // to a structure allocated by caller. 
                                   // sAddr->ip must contain the ip address/port of the
                                   // connection as a string containing a standard IP 
                                   // numeric address, optionally followed by port 
                                   // specification of the form: "x.x.x.x[:nnn]"
                                   // If IP is not specified, the value 127.0.0.1 is used.
                                   // if port is not specified, the environment
                                   // variable MSGD_PORT is checked. If this
                                   // is not defined the default value MSGD_PORT
                                   // is used.
                                   // If the connection is established, connection 
                                   // socket is returned here.
{
struct sockaddr_in their_addr; 
int yes=1;
int asock;
int stat=NO_ERROR;
int flags;

if ((asock = socket(AF_INET, SOCK_STREAM, 0)) == -1)
    return SYSTEM_ERROR(NETWORK_ERROR);

if (setsockopt( asock,  SOL_TCP, TCP_NODELAY, &yes, sizeof(int)) == -1)
    return SYSTEM_ERROR(NETWORK_ERROR);
    
stat=NormalizeIP(tserv->ip,sizeof(tserv->ip),&their_addr);

// Set socket non blocking for short timeout in failed connection
flags = fcntl(asock,F_GETFL,0);
if(flags==-1)
    return SYSTEM_ERROR(NETWORK_ERROR);
fcntl(asock, F_SETFL, flags | O_NONBLOCK);  // Set socket non-blocking
                                                   // Connect to MsgD_RTDB
if (connect(asock,(struct sockaddr *)&their_addr,sizeof(struct sockaddr))==-1) {
    if(errno==EINPROGRESS) {            // Waiting for connection
       fd_set fds;
       struct timeval tv;
       int sel;

       FD_ZERO(&fds);
       FD_SET(asock,&fds);
       tv.tv_sec=1;
       tv.tv_usec=100000;
       sel=select(asock+1,NULL,&fds,NULL,&tv); // Wait for connection to establish
       if(sel>0) {                             // Now check if it is actually established
          int got;
          socklen_t optlen=sizeof(int);
          getsockopt(asock,SOL_SOCKET,SO_ERROR,&got,&optlen);
          if (got==0) stat=NO_ERROR;
       } else
          stat=COMMUNICATION_ERROR;
    } else
        stat = SYSTEM_ERROR(NETWORK_ERROR);
}

if(IS_ERROR(stat)) {
    close(asock);
    return stat;
}
                        // Reset the socket blocking
if(fcntl(asock, F_SETFL, flags) == (-1)) return SYSTEM_ERROR(NETWORK_ERROR);
tserv->sock=asock;
return NO_ERROR;
}

// @Function: ConnectTo 

// Register to a server
//
// This uses an opened connection to register the calling process as client.
//
// It is intended to be used exclusively as internal routine to this 
// library or by the MsgD-RTDB. 
//
//@

int ConnectTo(Connection *theServer, // Pointer to server connection data. This must
                                     // have been initialized by calling ConnectInit
              const char *MyName,    // Calling process name
              int    clType,         // clType. STD_CLIENT for standard clients
              MsgBuf *msgb)          // Message buffer
{                                    // @R: completion code 
int stat,len; 
char* pt;


pt=GetVersionID();
len=strlen(pt)+1;

if(MSG_BUFFER(msgb)==NULL)
    InitMsgBuf(msgb,len);                // Set up MsgBuf structure

FillHeader(0, 0, MyName, "",           // Prepare REGISTER COMMAND
                REGISTER, msgb);

FillBody(pt,len,msgb); // Put client identification data

HDR_FLAGS(msgb)=0;
HDR_PLOAD(msgb)=clType;

if(IS_ERROR(stat=SendToSK(theServer->sock,msgb))) {
    close(theServer->sock);
    theServer->sock=(-1);
    theServer->ip[0]='\0';
    return stat;
}
                                                  // Wait for ACK/NAK
if(IS_ERROR(stat=WaitMessage(theServer->sock,msgb))) {
    close(theServer->sock);
    theServer->sock=(-1);
    theServer->ip[0]='\0';
    return(stat);
}
    
if(HDR_CODE(msgb)==ACK) return NO_ERROR;

if(HDR_CODE(msgb) == NAK)
    stat = HDR_PLOAD(msgb);
else
    stat = ILLEGAL_MSG_ERROR; 

close(theServer->sock);
theServer->sock=(-1);
theServer->ip[0]='\0';

return PLAIN_ERROR(stat);
}


// @Function{API}: ConnectToServer 

// Opens a connection to the server
//
// This routine opens a bidirectional connection to the MsgD-RTDB and
// registers the calling process as client.
//
// Notes: 
//
// 1. This routine uses the connection socket synchronously, so it MUST 
//    be used before setting up the receive thread.
//
// 2. The system maintain the open server socket into an internal variable
//    thus any process can only call ConnectToServer() once.
//
// 3. Some special applications need to access the socket directly. 
//    For these special purposes see: GetServerSocket()
//
//@

int ConnectToServer(const char *sAddr, // @P{aAddr}: Server IP address
                                       //    It must be a string with a
                                       //    standard IP numeric address, optionally
                                       //    followed by port specification 
                                       //    of the form: "x.x.x.x[:nnn]"
                                       //    If port is not specified, the environment
                                       //    variable MSGD_PORT is checked. If this
                                       //    is not defined the default value MSGD_PORT
                                       //    is used.
                    const char *MyName,// Calling process name
                    int stat)          // @P{dummy}: This argument is kept for
                                       // API compatibility but is useless.
{                                      // @R: completion code 
snprintf(theServer.ip,sizeof(theServer.ip),"%s",sAddr);

stat = ConnectInit(&theServer);
if(IS_NOT_ERROR(stat)) stat = ConnectTo(&theServer,MyName,STD_CLIENT,&auxmsgb);
if(IS_NOT_ERROR(stat)) setSeed(hdr_PLOAD(auxmsgb));
return stat;
}

// @Function{API}: CloseServer 

// Closes the connection with the server
//
// This routine closes the bidirectional connection to the MsgD-RTDB.
// The MsgD-RTDB will unregister the client when sensing that
// the connection has been closed.
//
//@

int CloseServer(const char *Sender) // @P{Sender}: Client's name
                                    // @R: completion code 
{
   int stat; 
   if (theServer.sock == -1) 
      return PLAIN_ERROR(CLOSING_ERROR);
   
   FillHeader(0,0,Sender,"",UNREGISTER,&auxmsgb); // Prepare unregister command
   hdr_PLOAD(auxmsgb)=0;
   SendToServer(&auxmsgb);                        // Send unregister command
    
   stat=close(theServer.sock);
   theServer.sock=(-1);
   if (stat != 0)
      return SYSTEM_ERROR(NETWORK_ERROR);
   else
      return NO_ERROR;
}


// @Function{API}: SendToServer 

// Sends a message to the Msgd-RTDB server
//
// This routine sends a full message to the MsgD-RTDB server process.
// The message structure must be properly fileld prior to sending (see
// Header related routines)
//
//@

int SendToServer(MsgBuf *msgb)       // @P{msgb}: Message Structure
                                     // @R: Completion code
{
    return SendToSK(theServer.sock,msgb);
}



// @Function{API}: WaitMsgFromServer 

// Wait for a message sent by msgdrtdb
//
// NOTES 
// \begin{enumerate}
// \item The routine uses a special structure as message buffer (see
//       argument: buffer). The argument is a pointer to a structure which
//       MUST be properly initialized prior of the first call to this 
//       routine by calling InitMsgBuf().
//       The related resources can be released when the structure is
//       not used any longer by using the macro FreeMsgBuf().
//
//    Example:
//   \begin{verbatim}
//       #include "msglib.h"
//
//       MsgBuf MyMsgBuf;
//
//       ....
//       InitMsgBuf(&MyMsgBuf,0);         // Initialize
//
//       ....
//       WaitMsgFromServer(&MyMsgBuf)      // Get data
//       for(i=0;i<10;i++)                 // How to access data
//           a+=MSG_BODY(MyMsgBuf)[i];
//       ....
//       ....
//       ....
//       FreeMsgBuf(&MyMsgBuf);            // When finished with MyMsgBuf
//       ....
//   \end{verbatim}
//
// \item The buffer in the MsgBuf structure can be longer than any received 
//       message. Whenever the content of the buffer is accessed the MsgLen
//       field of the Header structure contains the number of message bytes
//       just received. The rest of the buffer bytes must be discarded.
// \end{enumerate}
//
// Note: on error return, some communication diagnostics may be derived
// from the value of field hd_ok in message buffer.
// if hd_ok=0: error occurred while waiting for message header
// if hd_ok=1: error occurred on header values or while waiting for message body
//@

int WaitMsgFromServer(MsgBuf *msg)      // MsgBuf structure
                                        // See comments to WaitMessage
{
    return WaitMessage(theServer.sock,msg);
}

// @Function{API}: WaitMsgTimeout 

// Wait for a message from msgdrtdb, with a timeout
//
// This routine behaves exactly like WaitMsgFromServer(), with an
// added timeout to stop waiting after a certain time.
// If the timeout expires, a TIMEOUT\_ERROR is returned.
//@


int WaitMsgTimeout( MsgBuf *msg,  // MsgBuf structure
                    int timeout)  // timeout in milliseconds
{
    fd_set rdfd;
    struct timeval tv;
    int retval;

    memset( &tv, 0, sizeof( struct timeval));
    FD_ZERO( &rdfd);
    FD_SET( theServer.sock, &rdfd);
    tv.tv_sec = timeout/1000;
    tv.tv_usec = (timeout-tv.tv_sec*1000)*1000;
   
    // This loop only works on Linux, because the tv struct
    // is re-initialized with the time left from the timeout

#ifndef __linux__
#error This function only works in Linux - see comments in the source code
#endif
 
   while(1) {
      retval = select( theServer.sock+1, &rdfd, NULL, NULL, &tv);
      if ((retval==-1) && (errno == EINTR))
         continue;
      else
         break;
   }

   if (retval==-1) 
      return PLAIN_ERROR(TIMEOUT_ERROR);

   if (retval)
      return WaitMessage( theServer.sock, msg);
   else
      return PLAIN_ERROR(TIMEOUT_ERROR);
}

// @Function{API}: WaitMessageSet

// Wait for a message matching specified list from msgdrtdb, with a timeout
//
// This routine waits for messages from msgdrtb matching a given list of
// "sequence numbers". If any received message has a sequence number 
// match any value in the sequence list, it returns the message, otherwise
// it calls the specified callback routine and keeps waiting after 
// callback routine return.

// When timeout is expired it returns with a TIMEOUT\_ERROR code
//@


int WaitMessageSet( int *msgSet,   // @P{msgSet}: array of request numbers 
                                   //             to wait for
                    int len,       // @P{len}:  length of message set array
                                   //  It must be >= 0.
                    MsgBuf *msgb,   // @P{msgb}: MsgBuf structure
                    MsgProc callbk,// @P{callbk}: Function to process messages
                                    //   not listed in message set. If NULL,
                                    //   such messages will be ignored.
                    int timeout)    // @P{timeout}: timeout in milliseconds. 
                                    // If 0, wait forever.
                                    // @R: Completion status
{
fd_set rdfd;
struct timeval tv;
struct timeval *tv_pt;
struct timeval now,expir;
int ret,i;

if(len<=0) return PLAIN_ERROR(VALUE_OUT_OF_RANGE_ERROR);

FD_ZERO( &rdfd);
FD_SET( theServer.sock, &rdfd);

if(timeout>0) {
    memset( &tv, 0, sizeof( struct timeval));
    tv.tv_sec = timeout/1000;
    tv.tv_usec = (timeout-tv.tv_sec*1000)*1000;
                                // Prepare variables to check timeout
                                // across multiple calls to select()
    gettimeofday(&expir, NULL);
    expir.tv_sec+=tv.tv_sec;
    expir.tv_usec+=tv.tv_usec;
    if(expir.tv_usec>1000000) {
        expir.tv_sec++;
        expir.tv_usec-=1000000;
    }
    tv_pt=&tv;
} else 
    tv_pt=NULL;
    
for(;;) {
    ret = select(theServer.sock+1, &rdfd, NULL, NULL, tv_pt);
    if (ret) {
        if(IS_ERROR(ret=WaitMessage(theServer.sock, msgb))) return ret;

        for(i=0; i<len; i++) {                // Check message seq.numb. against list
            if (HDR_SEQN(msgb) == (unsigned)msgSet[i])
                return ret;                   // Found.
        }
        if(callbk) callbk(msgb);        // Not found, possibly call callback routine

                                        // Verify timeout and compute
                                        // timeout for remaining time
        if(timeout>0) {
            gettimeofday(&now, NULL);
            if( (now.tv_sec>expir.tv_sec) ||
                (now.tv_sec==expir.tv_sec && now.tv_usec>expir.tv_usec)) break;
            tv.tv_sec = expir.tv_sec-now.tv_sec;
            tv.tv_usec = expir.tv_usec-now.tv_usec;
            if(tv.tv_usec<0) {
                tv.tv_sec++;
                tv.tv_usec+=1000000;
            }
        }
    } else
        break;
}
return PLAIN_ERROR(TIMEOUT_ERROR);
}




// @Function{API}: WaitClientReady

// Wait for a client to set its Ready flag
//
// This routine waits for a specified client to set its ready flag.
// The routine will return with NO\_ERROR state when the other client's
// notification is received.

// Note: The specified client must be "well behaved" , i.e.: if it
// doesn't call SetReady, the waiting client will never be notified. 

// When timeout is expired it returns with a TIMEOUT\_ERROR code
//@

int WaitClientReady(const char *myName,   // P{myName}: name of the calling client
                    const char *wtclient, // @P{wtclient}: Name of client to wait for
                    MsgBuf *msgb,         // @P{msgb}: MsgBuf structure
                    MsgProc callbk,       // @P{callbk}: Function to process messages
                                          //   not listed in message set. If NULL,
                                          //   such messages will be ignored.
                    int timeout)          // @P{timeout}: timeout in milliseconds. 
                                          // If 0, wait forever.
                                          // @R: Completion status
{
fd_set rdfd;
struct timeval tv;
struct timeval *tv_pt;
struct timeval now,expir;
int stat,lng;

lng=strlen(wtclient);
if(lng>PROC_NAME_LEN || lng<=0) return CLIENT_NAME_ERROR;

stat = FillMessage(lng+1,0, myName,"",WAITCLRDY,wtclient, msgb);
if(IS_NOT_ERROR(stat)) stat=SendToServer(msgb);   // Send request to MsgD-RTDB

if(IS_ERROR(stat)) return stat;

FD_ZERO( &rdfd);
FD_SET( theServer.sock, &rdfd);

if(timeout>0) {
    memset( &tv, 0, sizeof( struct timeval));
    tv.tv_sec = timeout/1000;
    tv.tv_usec = (timeout-tv.tv_sec*1000)*1000;
                                // Prepare variables to check timeout
                                // across multiple calls to select()
    gettimeofday(&expir, NULL);
    expir.tv_sec+=tv.tv_sec;
    expir.tv_usec+=tv.tv_usec;
    if(expir.tv_usec>1000000) {
        expir.tv_sec++;
        expir.tv_usec-=1000000;
    }
    tv_pt=&tv;
} else 
    tv_pt=NULL;
    
for(;;) {
    stat = select(theServer.sock+1, &rdfd, NULL, NULL, tv_pt);
    if (stat) {
        if(IS_ERROR(stat=WaitMessage(theServer.sock, msgb))) return stat;

        if(HDR_CODE(msgb)==CLNREADY) return stat;
        
        if(callbk) callbk(msgb);     // Unexpected message, possibly 
                                         // call callback routine

                                        // Verify timeout and compute
                                        // timeout for remaining time
        if(timeout>0) {
            gettimeofday(&now, NULL);
            if( (now.tv_sec>expir.tv_sec) ||
                (now.tv_sec==expir.tv_sec && now.tv_usec>expir.tv_usec)) break;
            tv.tv_sec = expir.tv_sec-now.tv_sec;
            tv.tv_usec = expir.tv_usec-now.tv_usec;
            if(tv.tv_usec<0) {
                tv.tv_sec++;
                tv.tv_usec+=1000000;
            }
        }
    } else
        break;
}
return PLAIN_ERROR(TIMEOUT_ERROR);
}




// @Function: GetServerSocket 

// Returns the socket used for server connection
//
// This function returns the socket number used for the server connection
//
// NOTE: Direct access to the server socket must be used very carefully.
// It actually should not be used in any case except for very special
// purposes. All usual message exchange must be done via calls to routines
// defined in this library
//@

int GetServerSocket(void)
{
    return theServer.sock;
}


// @Function{API}: LogMsg

// Send a log message to be managed by MsgD-RTDB
//
// This routine sends a log message to the MsgD-RTDB to be properly
// logged. It can be used to log either error messages or to
// log generic information. In the latter case the NO\_ERROR code must be
// used.

//       Error messages are generated by concatenating the standard error 
//       string associated with the error code, then a separator: " | ", then
//       the caller provided message.

//@


int LogMsg(const char *MyName, // @P(MyName}: Calling client's name
           int seqN,          // @P{seqN}: Log Identifier sequence number
           int level,         // @P{level}: Error level: 1=Fatal, 2=Error, 3=Waring, 4=Info
	    
           const char *msg )  // @P{msg}: log message
                              // @Ret: error status
{
  str_LOGSTAT loghdr;
  int ret;
  size_t size;

  if(msg==NULL) return UNSPECIFIED_LOG_MSG_ERROR;

  loghdr.txt[0]='\0'; 
  loghdr.txt[LOG_MAX-1]='\0'; 
  loghdr.seq=seqN;
  loghdr.lev=level;
  strncpy(loghdr.txt,msg,LOG_MAX-1);
  size=2*sizeof(int)+strlen(loghdr.txt)+1;

  ret = FillMessage(size, NewSeqN(),      // Prepare message
              MyName,"",LOGSTAT,&loghdr, &auxmsgb);
  if(IS_NOT_ERROR(ret))
    ret=SendToServer(&auxmsgb);                  // Send it to MsgD-RTDB

  return ret;
}


// @Function{API}: SetVersion

// Set version numbers for client identification
//
// This routine must be called before connecting to \msgd\  in
// order to specify version number for client identification.
//
// If not called version identification defaults to 0.0
//@

// Note: This routine is usually called via the macro SetVersion

void setvers(int vMajor,   //@P{vMajor}: Major version number (<= 1000)
             int vMinor,   //@P{vMinor}: Minor version number (< 1000)
             int thmode)
{
VersMaj=vMajor;
VersMin=vMinor;
VersthMode=thmode;
}

// @Function{API}: GetVersionID

// Get version itentification
//
// This routine returns a string with version identification
// adding to the numerical version value specified by calling 
// SetVersion() the build time.
//
// In order to actually determine the correct build time, the
// file build_time.c must be compiled just before linking the calling
// program. See Makefile in Tester directory for examples on how to
// force compilation
//@

char* GetVersionID(void)  //  @R: pointer to version identification string
{
static char vers_id[VERSION_ID_LNG];
char *pt;

if(VersthMode) 
   pt="[TH]";
else
   pt="";

snprintf(vers_id,VERSION_ID_LNG,"%d.%d %s%s",VersMaj,VersMin,pt,build_time());

return vers_id;
}

// @Function{API}: GetVersion

// Get numeric version
//
// This routine returns an integer with the version value coded as
// 1000*VERS_MAJOR+VERS_MINOR
// 
// See also SetVersion()
//
//@

int GetVersion(void)  //  @R: pointer to version identification string
{
return 1000*VersMaj+VersMin;
}


// @Function{API}: MsgDebug

// Set debug level (obsolete)
//
// This routine is obsolete: it does nothing
//
//@

void MsgDebug(int levl)  //  @P{levl}: Set to 1 to enable debug output
{
    msgDebug=0;
}


// @Function{API}: ipPort

// Returns MsgD-RTDB port number
//
//@

int ipPort(void)  // @R: MsgD-RTDB port number
                  //  (-1) if not connected.
{
int stat,port=(-1);
char *pt=index(theServer.ip,':');

if(pt) {
    pt++;
    stat=sscanf(pt,"%d",&port);
    if(stat!=1) port=(-1);
}
return port;
}

// @Function{API}: mkFullName

// Makes complete name from name, domain
//
//@

char * mkFullName(char *nm,    // @P{nm} Client name
                  char *dom,   // @P{dom} Domain
                  char *buff)  // @P{buff}: Buffer for result
                               //   size >= LONG_NAME_LEN+1
                               // @R: Pointer to buffer.
{
   if(dom && *dom) 
      snprintf(buff,LONG_NAME_LEN+1,"%s@%s",nm,dom);
   else
      snprintf(buff,LONG_NAME_LEN+1,"%s",nm);
   return buff;
}

