As of Sept 2009 I have slightly revised the architecture of the Arbitrators
in the aspects regarding the definition of the FSM which controls the sequence
of operations.

This has been done first for the AO Arbitrator, then applied to AdSec
arbitrator too.

The rason for doing that is to be able to use FSM code as generated by
the fsmc compiler with no modification whatsoever, so that the FSM is always
in synch with the description in the related .fsm file.

The mechanism as implemented for the AO Arbitrator is as follows:

1. The FSM is designed with FSME. The definition of the "root" must NOT define
   a Base Class (leave the correspondig field blank).

   All the other details are as before. See the example: AOArbFsmCore.fsm
   and AdSecFsmCore.fsm

2. The FSM core code is generated with two commands:

   	fsmc AOArbFsmCore.fsm -o AOArbFsmCore.h
	fsmc -impl AOArbFsmCore.h AOArbFsmCore.fsm -o AOArbFsmCore.cpp

    (see also Makefile in ../adsecarbitrator)

   
3. An FSM specific class must be created. In the example it has been defined
   in AOArbFsm.h (AdSecFsm.h) and implemented in AOArbFsm.cpp (AdSecFsm.cpp).

   The specific class is derived both from AOArbFsmCore and AbstractFsm. Its purpose
   is to implement the following methods:

       processCommand()     as required by AOArbFsmCore. This simply calls the
                            processCommand method provided by AbstractFsm.

       trigger(OpCode code) as required by AbstractFsm
       forceFailure()            ......
       forcePanic()              ......
       currentStateAsString()    ......

4. The implementation of "trigger" requires a function to convert the
   command OpCode into the related FSM Event. Unfortunately the list of
   events created by FSMC is implemented as a C++ "enum" and thus is not
   guaranteed to follow a particular sequenece. So the only way to make the
   association between OpCodes and Events is to manually code it. In the
   AOArbFsmCore and AdSecFsmCode examples a C++ map defined in the 
   constructor of AoArbFsm (AdSecFsm) is used.

   NOTE: this code must be manually modified whenever an event is added or
   removed from the FSM!

   Following this scheme, there is no need for manual modifications of
   the code generated by FSMC, except for the above mentioned association
   between OpCodes and Events. The Example code of AOArbFsm provides code
   to throw an exception when an OpCode cannot be associated with the
   corresponding event.

   NOTE. the code generator utility FSMC has been modified (it is
   version 1.1.1) to produce some useful additional methods:
 
      stateCode()  which returns the state enum value, given a state name
                   as string

      forceState() which forces the FSM to a given state

