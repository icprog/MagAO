;$Id: cal_data_analize.pro,v 1.1 2006/11/09 18:31:17 labot Exp $
;+
;   NAME:
;    CAL_DATA_ANALIZE
;
;   PURPOSE:
;    Restore a file generated by start_pos_calib.pro procedure and analize the data
;    in order to get the calibration paramters (d0 and Cstray)
;
;   USAGE:
;    output=cal_data_analize(FILE=filename, DISPLAY=display)
;
;   INPUT:
;    None.
;
;   OUTPUT:
;    output:    2D array with calibration parameters data. First column is the new
;               d0 value, second value is the Cstray value in Cref fraction.
;
;   KEYWORD:
;    INTERF_WAVE: the interferometer wavelength used for the measurement.
;    DISPLAY:     Display useful graphs and info for all operation.
;    DATAFILE:    Filename to restore. if unset, the filename will be requested interactivey.
;    WIRTE_FILES: if set, some files are written into temporary directory adsec_path.temp.
;    EXT:         extension to filename.
;    ACT_COORD:   out/in keyword in order to avoid the recomputation of actuator mapping.
;
; HISTORY
;   Oct 2006:   written by M.Xompero (MX)
;               marco@arcetri.astro.it
;-



Function cal_data_analize, DISPLAY=display , WRITE_FILES = write_files, EXT=ext, DATAFILE=file2restore, ACT_COORD=act_coord_in, INTERF_WAVE=interf_wave

    @adsec_common
    common display_block, fit_display

    if n_elements(interf_wave) eq 0 then interf_wave = 632.8d-9
    fit_display = keyword_set(DISPLAY)
    print, "Restore data..."
    if n_elements(file2restore) eq 0 then file2restore = dialog_pickfile(TITLE="PLEASE SELECT THE DATA FILE TO RESTORE:")
    print, "File: "+file2restore
    if file2restore eq "" then return , adsec_error.generic_error else restore, file2restore


    print, "Pupil recognizing and actuator mapping..."
    if n_elements(act_coord_in) eq 0 then begin
        act_coord = map_act(frames[*,*,0], MASK=mask, DISPLAY=display) 
    endif else begin
        print, "Skipped."
        act_coord=act_coord_in 
    endelse 
    frames_act = dblarr(n_elements(adsec.true_act), max(size(frames, /DIM)))
    for i=0, n_elements(adsec.true_act)-1 do begin
        frames_act[i,*] = reform(frames[act_coord[0,adsec.true_act[i]], act_coord[1,adsec.true_act[i]], *])
        volt_act = reform(buf_volt[*,0,adsec.true_act])
    endfor
    time_frames = timef
;    save, file='tmp.sav', frames_act, time_frames, volt_act, volt_time, mask
;    restore, 'tmp.sav', /ver


    print, "Cut the data and scaling time..."
    ;frames
    ;pos = data_cut(frames, mask=mask)
    pos = data_cut(frames_act)
    frames_act_cut = frames_act[*,pos[0]:pos[1]]
    time_frames_cut = time_frames[pos[0]:pos[1]]

    ;voltage
    dummy_id = where(time_hist[*,0]-time_hist[0,0] lt 0)
    min_idv = dummy_id[0]
    dummy_id = where(time_hist[*,0]-time_hist[max(size(time_hist,/DIM))-1,0] gt 0, cc)
    max_idv = dummy_id[cc-1]

    volt_act_cut = reform(buf_volt[min_idv:max_idv,0,adsec.true_act])
    time_volt_cut = volt_time[min_idv:max_idv]

    time_volt_cut = time_volt_cut - time_volt_cut[0]
    time_frames_cut = time_frames_cut - time_frames_cut[0]
    fact = max(time_frames_cut)/max(time_volt_cut)
    time_frames_cut = time_frames_cut / fact
    
    adc_bits = adsec.adc_bits
    vratio = adsec.capsens_vmax/adsec.capsens_vref
    ;; d = d0/(vratio*V_adc/2^adc_bits - c) = dist_A_coeff/(V_adc + dist_B_coeff)
    volt_act_cut = vratio*volt_act_cut/(2d0^adc_bits)



    print, "Get the calibration parameters..."
    params = dblarr(3, n_elements(adsec.true_act))

    residue = dblarr(300*n_elements(adsec.true_act)) + !values.d_infinity
    x_over_real = dblarr(300*n_elements(adsec.true_act)) + !values.d_infinity
    id_res=indgen(n_elements(adsec.true_act))
    for i=0, n_elements(adsec.true_act)-1 do begin

        params[*,i] =comp_small_fit(volt_act_cut[*,i], frames_act_cut[i,*], time_volt_cut, time_frames_cut, RESIDUE=tmp_res, X_OVER=tmp_xor, INTERF_WAVE=interf_wave)
        residue[id_res[i]:id_res[i]+n_elements(tmp_res)-1] = tmp_res
        x_over_real[id_res[i]:id_res[i]+n_elements(tmp_xor)-1] = tmp_xor

        if i ne (n_elements(adsec.true_act)-1) then begin
            id_res[i+1] = id_res[i]+n_elements(tmp_res)
        endif else begin
            dummy_id = where(finite(residue))
            residue = residue[dummy_id]
            x_over_real = x_over_real[dummy_id]
            undefine, dummy_id
        endelse

    endfor

    ff = file_basename(file2restore)
    save, file = adsec_path.temp+"result_params_"+ff, params, residue, x_over_real, id_res, adsec_save, interf_wave

    if keyword_set(WRITE_FILES) then begin
        if n_elements(ext) eq 0 then ext=""
        d0 = fltarr(adsec.n_actuators)
        d0[adsec.dummy_act] = adsec.d0[adsec.dummy_act]
        d0[adsec.act_w_cl] = params[0,*]
        cs = fltarr(adsec.n_actuators)
        cs[adsec.dummy_act] = adsec.d0[adsec.dummy_act]
        cs[adsec.act_w_cl] = params[1,*]
        openw, unit, adsec_path.temp+"d0_calibrated"+ext+".txt" ,/GET_LUN
        printf, unit, "float 48"
        printf, unit, d0
        free_lun, unit
        openw, unit, adsec_path.temp+"cr_calibrated"+ext+".txt" ,/GET_LUN
        printf, unit, "float 48"
        printf, unit, cs
        free_lun, unit
        print, "d0_calibrated.txt and cs_calibrated.txt write into temporary folder."
    endif

    act_coord_in = act_coord

    return, params

End
