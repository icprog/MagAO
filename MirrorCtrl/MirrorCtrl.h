/*
 * @File: MirrorCtrl.h
 * Defines the main class for the Mirror controller process
 * @
 */

#include <vector>
#include <list>
#include <string>
#include <fstream>
#include <iostream>
#include <iostream>
using namespace std;

// Libs
#include "AOApp.h"

#include "BcuCommunicator/BcuCommunicator.h"
#include "RequestManagers/BcuCommandHandler.h"
#include "RequestManagers/DiagnosticManagerPool.h"
#include "RequestManagers/DiagnosticManager.h"
#include "RequestManagers/Watchdog.h"
#include "AdamLib.h"

typedef map<int, BcuCommunicator*> BcuCommunicatorPool;


/*
 * @Class: MirrorCtrl
 * 
 * Controller managing the communication with the pool of BCU in the system (Wfs and Adaptive Secondary).
 *
 * \subsection*{Main features}
 * 
 * 	- Send Bcu Commands (generated by the BcuCommon library) to BCUs, handling the 
 * 	  request unpacking, failures, retry mechanism, and so on.
 *  - Performs diagnostics defined in its config file
 *  - On request, run a watchdog for the BCUs of the Adaptive Secondary.
 *
 * \subsection*{Steps}
 *
 *  Let's consider a set of N BCUs defined in files lib/AdSecConstants.h e lib/WfsConstants.h.
 * 
 * 	1. Read the configuration file, mirrorctrl.conf, to know the BCU Ip Addresses and some more info.
 *  2. Creates a set of N BcuCommunicators (@see{BcuCommunicator}), one for each valid entry of the config file.
 *  3. Creates a set of BcuCommandHandlers (@see{BcuCommandHandler}) and register their execute(...) methods with thrdlib. Each
 * 	   BcuCommandHandler handle a specific set of Bcu Command, to allow the maximum concurrency.
 *  4. Creates K DiagnosticManagers (@see{DiagnosticManager}) from K entries in a diagnostic config file.
 * 	5. If requested, create a Watchdog (@see{Watchdog}) thread
 *  5. For each BcuCommunicator created, add to it all producers (objects derived from AbstractBcuRequestManager,
 * 	   such as BcuCommandHandler, DiagnosticManager and Watchdog) interested in communicating with the
 * 	   corresponding Bcu.
 *  6. Starts all Bcu Communicators, Diagnostic Manager and Watchdog as separated threads.
 * 	7. Handle application termination to guarantee a graceful shutdown.
 * 
 * @
 */
class MirrorCtrl: public AOApp {
    
    public:
	MirrorCtrl(int argc, char **argv) throw (AOException);

	void Create() throw (AOException);
        
        virtual ~MirrorCtrl();
        
        int getBcuNum();
        void setBcuNum(int bcuNum);
        
        /*
         * @MethodSet:  handle[XX][PR]Request
      	 * Handle a high-priority or low-priority request from msgD.
      	 * 
      	 * Used by thlib to notify MirrorCtrl when a message arrive. 
      	 * Note that, as the methods are static (not thread-safe), 
      	 * I need to define two different methods for LP and HP BcuRequests:
      	 * both methods forwards the request to the correct BcuCommandHandler
      	 * object.
      	 * @
      	 */
      	
      	/*
      	 * @Method: handle39HpRequest
      	 * Handle a high-priority request to Bcu39
      	 * @
      	 */
        static int handle39HpRequest(MsgBuf* msgBuf, void *lpCmdHdlPtr, int hndlrQueueSize);
        
        /*
      	 * @Method: handle39LpRequest
      	 * Handle a low-priority request to Bcu39
      	 * @
      	 */
        static int handle39LpRequest(MsgBuf* msgBuf, void *hpCmdHdlPtr, int hndlrQueueSize);
        
        /*
      	 * @Method: handle47HpRequest
      	 * Handle a high-priority request to Bcu47
      	 * @
      	 */
        static int handle47HpRequest(MsgBuf* msgBuf, void *lpCmdHdlPtr, int hndlrQueueSize);
        
        /*
      	 * @Method: handle47LpRequest
      	 * Handle a low-priority request to Bcu47
      	 * @
      	 */
        static int handle47LpRequest(MsgBuf* msgBuf, void *hpCmdHdlPtr, int hndlrQueueSize);
        
        /*
      	 * @Method: handleSwitchHpRequest
      	 * Handle a high-priority request to BcuSwitch
      	 * @
      	 */
        static int handleSwitchHpRequest(MsgBuf* msgBuf, void *lpCmdHdlPtr, int hndlrQueueSize);
        
        /*
      	 * @Method: handleSwitchHpRequest
      	 * Handle a low-priority request to BcuSwitch
      	 * @
      	 */
        static int handleSwitchLpRequest(MsgBuf* msgBuf, void *hpCmdHdlPtr, int hndlrQueueSize);
        
        /*
      	 * @Method: handleMirrorHpRequest
      	 * Handle a high-priority request to BcuMirror set
      	 * @
      	 */
        static int handleMirrorHpRequest(MsgBuf* msgBuf, void *lpCmdHdlPtr, int hndlrQueueSize);
        
        /*
      	 * @Method: handleMirrorLpRequest
      	 * Handle a low-priority request to BcuSMirror set
      	 * @
      	 */
        static int handleMirrorLpRequest(MsgBuf* msgBuf, void *hpCmdHdlPtr, int hndlrQueueSize);
        
        /*
         * @Method: handleUnexpectedRequest
         * Handle unexpected request, simply 
         * @
         */
        static int handleUnexpectedRequest(MsgBuf* msgBuf, void* thisPtr, int hndlrQueueSize);
        
        /*
         * Handler notified when the Tech Viewer's frame size variable
         * changes
         */
        static int changeTechViewerFrameSizeHdlr(void *thisPtr, Variable *var);
        
        
    
    protected:
    
        /*
         * @Method: InstallHandlers
         * Install handlers for incoming Bcu requests from MsgD.
         */
        void InstallHandlers();
        
        /*
         * Install some handlers to switch on/off diagnostic 
         * managers
         */
        void SetupVars();
    
        // Execute the threads performing diagnostic (DiagnosticManager)
        void Run();
    
    private:
    
    	// Limit for the thrdlib queue size
    	// [todo] Set to a reasonable size!
    	static const int HNDLR_QUEUE_LIMIT = 100;
    
        // Number of BCUs (that is, Bcu Communicators) running in the system
        int _totalBcuNum;
        int _mirrorBcuNum;
        int _switchBcuNum;
        
        // Number of Diagnostic Manager running in the system
        int _diagnNum;
    
        // Handlers for high and low priority Bcu Commands from MsgD
        BcuCommandHandler* _lowPriorityCmdHandler39;
        BcuCommandHandler* _highPriorityCmdHandler39;      
        BcuCommandHandler* _lowPriorityCmdHandler47;
        BcuCommandHandler* _highPriorityCmdHandler47;  
        BcuCommandHandler* _lowPriorityCmdHandlerSwitch;
        BcuCommandHandler* _highPriorityCmdHandlerSwitch;
        BcuCommandHandler* _lowPriorityCmdHandlerMirror;
        BcuCommandHandler* _highPriorityCmdHandlerMirror;
        
        pthread_t _lowPriorityCmdHandler39Thread;
        pthread_t _highPriorityCmdHandler39Thread;
        pthread_t _lowPriorityCmdHandler47Thread;
        pthread_t _highPriorityCmdHandler47Thread;
        pthread_t _lowPriorityCmdHandlerSwitchThread;
        pthread_t _highPriorityCmdHandlerSwitchThread;
        pthread_t _lowPriorityCmdHandlerMirrorThread;
        pthread_t _highPriorityCmdHandlerMirrorThread;
        
        /*
         * RTDB variables to handle frame size change for Technical
         * Viewer
         */
        RTDBvar _techViewerFrameSize;
        
        /*
         * Thread sending a periodic "I'm alive packet to all MIRRORBCU
         */
        Watchdog* _watchdogMirror;
        pthread_t _watchdogMirrorThread;
        
        /*
         * Thread sending a periodic "I'm alive packet to SWITCHBCU
         */
        Watchdog* _watchdogSwitch;
        pthread_t _watchdogSwitchThread;
        
        /*
         * Thread sending a watchdog to ADAM device
         */
        AdamWatchdog* _watchdogAdam;
        
        // Pool of threads performing diagnostic download
        DiagnosticManagerPool* _diagnManagersPool;
        
        // Pool of threads performing connections to BCUs
        BcuCommunicatorPool _bcuCommunicators; 
        
        /*
         * Handler for frame size change of the Technical
         * Viewer
         */
        void changeTechViewerFrameSize(unsigned int frameSizePx);
        
        /*
         * Read the Diagnostics config files and return a list with the text lines.
         * Each line corresponds to a set of config parameters for a DiagnosticManager
         */
        list<string> readDiagnosticConfig() throw (Config_File_Exception);
        
};

