;$Id: comp_small_fit.pro,v 1.2 2006/11/14 11:37:05 labot Exp $
;+
;   NAME:
;    COMP_SMALL_FIT
;
;   PURPOSE:
;    Restore a file generated by start_pos_calib.pro procedure and analize the data
;    in order to get the calibration paramters (d0 and Cstray)
;
;   USAGE:
;    output = comp_small_fit(xx, yy, time_xx, time_yy, TH=th)
;
;   INPUT:
;    xx:        normalized voltage data
;    yy:        video data
;    time_xx:   time vector of x acquisition
;    time_yy:   time vector of y acquisition
;
;   OUTPUT:
;    output:    fitted parameters
;
;   KEYWORD:
;    TH:      thresholding for max recognizing. If unset, default value 0.5 is used.
;    INTERF_WAVE: interferometer wavelength (default 632.8d-9).
;
; HISTORY
;   Oct 2006:   written by M.Xompero (MX)
;               marco@arcetri.astro.it
;-
Function comp_d_real, x, time_x, peaks_pos, peaks_neg, ptv_dist, TIMED=time_d_real
 
    @adsec_common
    common display_block, fit_display

    min_neg = min(peaks_neg)
    min_pos = min(peaks_pos)
    if min_neg lt min_pos then begin
        first=peaks_neg
        second = peaks_pos
    endif else begin
        first=peaks_pos
        second = peaks_neg
    endelse
    
    d_real = dblarr(n_elements([peaks_pos,peaks_neg]))
    time_d_real = d_real
    d_real[0] = 0;;;;; DA DEFINIRE IL PASSO ZERO PER LA CORRIEZIONE DI FASE
    time_d_real[0] = time_x[0]
    id_sec = 0
    id_fir = 0
    i=1b

    while (id_fir+id_sec) ne n_elements(d_real)-1 do begin

        if i then time_d_real[id_fir+id_sec+1]=time_x[first[id_fir]] $
             else time_d_real[id_fir+id_sec+1]=time_x[second[id_sec]]

        d_real[id_fir+id_sec+1]=d_real[id_fir+id_sec]+ptv_dist
        if i then id_fir +=1 else id_sec += 1
        i = ~i
        
    endwhile

    adc_bits = adsec.adc_bits
    vratio = adsec.capsens_vmax/adsec.capsens_vref
    xb = x/vratio*2d0^adc_bits
    ; d = d0/(vratio*V_adc/2^adc_bits - c) = dist_A_coeff/(V_adc + dist_B_coeff)
    dist_B_coeff = float(-(adsec.c_ratio[0]*2d0^adc_bits/vratio)) ;[adcbit]
    dist_A_coeff = float(adsec.alpha_pos[0]) * float(2d0^adc_bits/vratio*adsec.d0[0]) ;[m*adcbit]

    ds = dist_A_coeff/(xb + dist_B_coeff)
    d_real = d_real+ds[0]    
    
;    if fit_display then begin
;        window, 1, TITLE="Residue d_real Fit"
;        plot, time_x, ds, yr=[30e-6,80e-6], xs=17,  xtitle="[s]", ytitle="[um]"
;        oplot, time_d_real, d_real, col=255l
;    endif

    return, d_real

End


Pro interpXonY, xx, yy, time_xx, time_yy, x, y, time 

    y=double(reform(yy))
    xx = reform(xx)
    y -= mean(y)
    ny = n_elements(yy)
    if n_elements(xx) ne n_elements(yy) then begin

        if n_elements(delay) eq 0 then delay=0    
        idx_yy = (time_yy-delay -min(time_xx))/(max(time_xx)-min(time_xx))*n_elements(time_xx)
        x = interpolate(double(xx), idx_yy)
        time = time_yy
        
    endif else begin
        
        x = double(xx)
        time = double(time_xx)
    
    endelse



End

Pro roughtPhaseUnWrap, x, y, time, TH=th, peaks_pos, peaks_neg

    common display_block, fit_display
    ny = n_elements(y)
    amp = (max(y)-min(y))/2.
    if n_elements(th) eq 0 then thrs=0.5*amp else thrs=th

    id_pos = where(y gt thrs, npos)
    id_neg = where(y lt -thrs, nneg)
    peaks_pos = make_array(npos, value=-1d)
    peaks_neg = make_array(nneg, value=-1d)

    ;max searching initial conditions
    first_neg = id_pos[0] gt id_neg[0]
    id_vec = lindgen(ny)
    curr_pos=0
    curr_neg=0
    last_pos=0
    last_neg=0
    end_array=0b
    end_array_pos=0
    end_array_neg=0
    i=0
    if first_neg then begin
        while ~(end_array_neg and end_array_pos) do begin

            ;if curr_pos ge n_elements(id_pos) then begin
            if end_array_pos then begin
                last_neg = n_elements(id_neg)-1
            endif else begin           
                ;aggiorno il negativo
                dummy = id_pos[curr_pos] -1 > 0
                dummy2 = where(id_neg le dummy)
                last_neg = dummy2[n_elements(dummy2)-1] 
            endelse

            if fit_display then print, "range neg", id_neg[curr_neg:last_neg]
            dummy = min(y[id_neg[curr_neg:last_neg]],idd)
            peaks_neg[i] = (id_neg[curr_neg:last_neg])[idd]
            ;end_array = ((n_elements(id_pos)-1) eq last_pos) and  ((n_elements(id_neg)-1) eq last_neg)
            end_array_neg =   ((n_elements(id_neg)-1) eq last_neg)

            ;if ~end_array_neg then curr_neg = last_neg+1
            curr_neg = last_neg+1
            if end_array_neg and end_array_pos then break

            ;if curr_neg ge n_elements(id_pos) then begin
            if end_array_neg then begin
                last_pos = n_elements(id_pos)-1
            endif else begin           
                ;aggiorno il positivo
                dummy = id_neg[curr_neg] -1 > 0
                dummy2 = where(id_pos le dummy)
                last_pos = dummy2[n_elements(dummy2)-1] 
            endelse
            if fit_display then print, "range pos", id_pos[curr_pos:last_pos]
            dummy = max(y[id_pos[curr_pos:last_pos]],idd)
            peaks_pos[i] = (id_pos[curr_pos:last_pos])[idd]
            ;end_array = ((n_elements(id_pos)-1) eq last_pos) and  ((n_elements(id_neg)-1) eq last_neg)
            end_array_pos = ((n_elements(id_pos)-1) eq last_pos) 
            ;if ~end_array_pos then curr_pos = last_pos+1 
            curr_pos = last_pos+1 
            i=i+1
        
        endwhile

    endif else begin

        while ~(end_array_neg and end_array_pos) do begin

            if end_array_neg then begin
                last_pos = n_elements(id_pos)-1
            endif else begin           
                ;aggiorno il positivo
                dummy = id_neg[curr_neg] -1 > 0
               ; dummy = id_neg[last_neg] > 0
                dummy2 = where(id_pos le dummy)
                last_pos = dummy2[n_elements(dummy2)-1] 
            endelse

            if fit_display then print, "range pos", id_pos[curr_pos:last_pos]
            dummy = max(y[id_pos[curr_pos:last_pos]],idd)
            peaks_pos[i] = (id_pos[curr_pos:last_pos])[idd]
            
            end_array_pos = ((n_elements(id_pos)-1) eq last_pos) 
            if end_array_neg and end_array_pos then break
            curr_pos = last_pos+1;

            if end_array_pos then begin
                last_neg = n_elements(id_neg)-1
            endif else begin           
                ;aggiorno il positivo
                dummy = id_pos[curr_pos] -1 > 0
;                dummy = id_pos[last_pos] > 0
                dummy2 = where(id_neg le dummy)
                last_neg = dummy2[n_elements(dummy2)-1] 
            endelse
            if fit_display then print, "range neg",  id_neg[curr_neg:last_neg]
            dummy = min(y[id_neg[curr_neg:last_neg]],idd)
            peaks_neg[i] = (id_neg[curr_neg:last_neg])[idd]
            end_array_neg = ((n_elements(id_neg)-1) eq last_neg) 
            curr_neg = last_neg+1 
            i=i+1
                
        endwhile
 

    endelse

    ;cut the array to the right dimension
    peaks_pos = peaks_pos[where(peaks_pos gt 0)]
    peaks_neg = peaks_neg[where(peaks_neg gt 0)]

    ;remove first and last peak to avoid false peaks
;    min_neg = min(peaks_neg) le min(peaks_pos)
;    if min_neg then peaks_neg = peaks_neg[1:n_elements(peaks_neg)-1] $
;               else peaks_pos = peaks_pos[1:n_elements(peaks_pos)-1]


;    max_neg = max(peaks_neg) gt max(peaks_pos)
;    if max_neg then peaks_neg = peaks_neg[0:n_elements(peaks_neg)-2] $
;               else peaks_pos = peaks_pos[0:n_elements(peaks_pos)-2]

    if fit_display then begin
    
        !p.multi=[0,1,2]        
        window, /free, TITLE="Signal and peaks"
        plot, x, y, psym=-4, xr=[x[0],x[20]],xs=17,  xtitle="[Vnorm]", ytitle="[Bit]"
        oplot, [min(x),max(x)],[0,0], col=255l
        oplot, [min(x),max(x)],[thrs,thrs], col=255l*256l
        oplot, [min(x),max(x)],[-thrs,-thrs], col=255l*256l
        plots, x[peaks_pos], y[peaks_pos], psym=2, col=255l*256*256, thick=2
        plots, x[peaks_neg], y[peaks_neg], psym=2, col=255l*256*256, thick=2
        plot, x, y, psym=-4, xr=[x[n_elements(x)-21],x[n_elements(x)-1]],xs=17,  xtitle="[Vnorm]", ytitle="[Bit]"
        oplot, [min(x),max(x)],[0,0], col=255l
        oplot, [min(x),max(x)],[thrs,thrs], col=255l*256l
        oplot, [min(x),max(x)],[-thrs,-thrs], col=255l*256l
        plots, x[peaks_pos], y[peaks_pos], psym=2, col=255l*256*256, thick=2
        plots, x[peaks_neg], y[peaks_neg], psym=2, col=255l*256*256, thick=2
        !p.multi = 0
        wait, 1
    endif

    return
End

Function comp_small_fit, xx, yy, time_xx, time_yy, TH=th, RESIDUE=residue, X_OVER_REAL=x_over_real, INTERF_WAVE=interf_wave

    common display_block, fit_display
    fit_display=0
    if fit_display then begin
        print, 'VOLTAGE RANGE:', minmax(xx)
    endif
    if n_elements(interf_wave) eq 0 then interf_wave=632.8d-9
    
    interpXonY, xx, yy, time_xx, time_yy, x, y, time
    
    roughtPhaseUnWrap, x, y, time, TH=th, peaks_pos, peaks_neg

    tmp = linfit(findgen(n_elements(xx)), xx)
    sign = (-1)^(tmp[1] gt 0)

    ;save, file="tmp_d.sav", peaks_pos, peaks_neg, x, y, time
    ;d_real = comp_d_real2(x, y, time, peaks_pos, peaks_neg, sign*interf_wave/4., TIMED=time_d_real)
    d_real = comp_d_real(x, time, peaks_pos, peaks_neg, sign*interf_wave/4., TIMED=time_d_real)
    ;d_real = comp_d_real(x, time, peaks_pos, peaks_neg, -632.8d-9/4., TIMED=time_d_real)

    ;time adjusting
    idx_yy = (time_d_real-min(time_xx))/(max(time_xx)-min(time_xx))*n_elements(time_xx)
    x_over_real = interpolate(double(xx), idx_yy)
    time_x_real = time_d_real
    pack = [[x_over_real], [d_real], [time_x_real]]

    return, pack
        
    ;params = fit_d0(x_over_real,d_real, RESIDUE=residue)

;   params: d0, c_stray, phi*lambda/4*DPI
;   we add: [amplitute params] and suppose zero mean
    
    ;return, params
End


