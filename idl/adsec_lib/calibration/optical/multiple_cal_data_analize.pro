;$Id: multiple_cal_data_analize.pro,v 1.4 2007/01/11 17:34:43 labot Exp $
;+
;   NAME:
;    CAL_DATA_ANALIZE
;
;   PURPOSE:
;    Restore a file generated by start_pos_calib.pro procedure and analize the data
;    in order to get the calibration paramters (d0 and Cstray)
;
;   USAGE:
;    output=cal_data_analize(FILE=filename, DISPLAY=display)
;
;   INPUT:
;    None.
;
;   OUTPUT:
;    output:    2D array with calibration parameters data. First column is the new
;               d0 value, second value is the Cstray value in Cref fraction.
;
;   KEYWORD:
;    INTERF_WAVE: the interferometer wavelength used for the measurement.
;    DISPLAY:     Display useful graphs and info for all operation.
;    DATAFILE:    Filename to restore. if unset, the filename will be requested interactivey.
;    WIRTE_FILES: if set, some files are written into temporary directory adsec_path.temp.
;    EXT:         extension to filename.
;    ACT_COORD:   out/in keyword in order to avoid the recomputation of actuator mapping.
;
; HISTORY
;   Oct 2006:   written by M.Xompero (MX)
;               marco@arcetri.astro.it
;-



Function multiple_cal_data_analize, DISPLAY=display , WRITE_FILES = write_files, EXT=ext, DATAFILE=file2restore, ACT_COORD=act_coord_in, INTERF_WAVE=interf_wave, SINGLE=single

    @adsec_common
    common display_block, fit_display

    if n_elements(interf_wave) eq 0 then interf_wave = 632.8d-9
    fit_display = keyword_set(DISPLAY)
    if n_elements(file2restore) eq 0 then file2restore = dialog_pickfile(TITLE="PLEASE SELECT THE DATA FILE TO RESTORE:")
    if keyword_set(single) then begin
        names = file2restore
    endif else begin
        base = file_basename(file2restore)
        dir = file_dirname(file2restore)
        step_filter = stregex(base,'.*step.', /extract)
        meas_filter  = stregex(base,'_meas_.*', /extract)
        names = file_search(dir, step_filter+'*'+meas_filter)
    endelse


    for k=0, n_elements(names)-1 do begin
    
        print, "Restore data..."
        print, "File: "+names[k]
        if names[k] eq "" then return , adsec_error.generic_error else restore, names[k]

        print, "Pupil recognizing and actuator mapping..."
        if n_elements(act_coord_in) eq 0 then begin
            act_coord = map_act(frames[*,*,0], MASK=mask, DISPLAY=display) 
            act_coord_in = act_coord
        endif else begin
            print, "Skipped."
            act_coord=act_coord_in 
        endelse 
        frames_act = dblarr( (size(frames, /DIM))[2], n_elements(adsec.true_act))
        for i=0, n_elements(adsec.true_act)-1 do begin
            frames_act[*,i] = reform(frames[act_coord[0,adsec.true_act[i]], act_coord[1,adsec.true_act[i]], *])
        endfor
        undefine, frames
        time_frames = timef
    ;    restore, 'tmp.sav', /ver


        print, "Cut the data and scaling time..."
        ;frames
        ;pos = data_cut(frames, mask=mask)
        pos = data_cut(frames_act, TURB_RMS=turb_rms)
        frames_act_cut = frames_act[pos[0]:pos[1], *]
        time_frames_cut = time_frames[pos[0]:pos[1]]

        ;voltage
        dummy_id = where(abs(time_hist[*,0]-time_hist[0,0]) gt 0)
        min_idv = dummy_id[0]
        dummy_id = where(abs(time_hist[*,0]-time_hist[max(size(time_hist,/DIM))-1,0]) gt 0, cc)
        max_idv = dummy_id[cc-1]

        volt_act_cut = reform(buf_volt[min_idv:max_idv,0,adsec.true_act])
        undefine, buf_volt
        time_volt_cut = volt_time[min_idv:max_idv]
    
        adc_bits = adsec.adc_bits
        vratio = adsec.capsens_vmax/adsec.capsens_vref
        ;; d = d0/(vratio*V_adc/2^adc_bits - c) = dist_A_coeff/(V_adc + dist_B_coeff)
        volt_act_cut = vratio*volt_act_cut/(2d0^adc_bits)

        ;time
        time_volt_cut = time_volt_cut - time_volt_cut[0]
        time_frames_cut = time_frames_cut - time_frames_cut[0]
        fact = max(time_frames_cut)/max(time_volt_cut)
        time_frames_cut = time_frames_cut / fact

        if k eq 0 then begin
            id_volt = dblarr(n_elements(names)+1)
            id_frames = dblarr(n_elements(names)+1)
            id_volt[k+1] = n_elements(volt_act_cut[*,0])
            id_frames[k+1] = n_elements(frames_act_cut[*,0])
            new_volt_act_cut = volt_act_cut
            new_frames_act_cut = frames_act_cut
            new_time_volt_cut = time_volt_cut
            new_time_frames_cut =time_frames_cut
        endif else begin
            id_volt[k+1] = id_volt[k]+n_elements(volt_act_cut[*,0])
            id_frames[k+1] = id_frames[k]+n_elements(frames_act_cut[*,0])
            new_volt_act_cut = [new_volt_act_cut,volt_act_cut]
            new_frames_act_cut = [new_frames_act_cut,frames_act_cut]
            new_time_volt_cut = [new_time_volt_cut,time_volt_cut]
            new_time_frames_cut =[new_time_frames_cut, time_frames_cut]
        endelse
      
endfor


    print, "Get the calibration parameters..."
    params = dblarr(2, n_elements(adsec.true_act))
    perror = dblarr(2, n_elements(adsec.true_act))

    residue = dblarr(2000*n_elements(adsec.true_act)) + !values.d_infinity
    x_over_real = dblarr(2000*n_elements(adsec.true_act)) + !values.d_infinity
    id_res=indgen(n_elements(adsec.true_act))
    for i=0, n_elements(adsec.true_act)-1 do begin
        for k=0, n_elements(names)-1 do begin

            pack = comp_small_fit(new_volt_act_cut[id_volt[k]:id_volt[k+1]-1,i], new_frames_act_cut[id_frames[k]:id_frames[k+1]-1, i] $
                                , new_time_volt_cut[id_volt[k]:id_volt[k+1]-1], new_time_frames_cut[id_frames[k]:id_frames[k+1]-1]    $
                                , INTERF_WAVE=interf_wave)
 
            if k eq 0 then begin
                v_global = pack[*,0]
                d_global = pack[*,1]
            endif else begin
                v_tmp = pack[*,0]
                d_tmp = (pack[*,1]-pack[0,1])+d_global[n_elements(d_global[*,0])-1]
                v_global = [v_global, v_tmp]
                d_global = [d_global, d_tmp]
            endelse

        endfor
        print, "Fit actuator #"+strtrim(i,2)
        params[*,i] = fit_d0(v_global, d_global, residue=tmp_res, err=turb_rms, perr=perr)
        perror[*,i] = perr
        
;        params[*,i] =comp_small_fit(new_volt_act_cut[*,i], new_frames_act_cut[*, i], new_time_volt_cut, new_time_frames_cut, RESIDUE=tmp_res, X_OVER=tmp_xor, INTERF_WAVE=interf_wave)
        residue[id_res[i]:id_res[i]+n_elements(tmp_res)-1] = tmp_res
        x_over_real[id_res[i]:id_res[i]+n_elements(v_global)-1] = v_global

        if i ne (n_elements(adsec.true_act)-1) then begin
            id_res[i+1] = id_res[i]+n_elements(tmp_res)
        endif else begin
            dummy_id = where(finite(residue))
            residue = residue[dummy_id]
            x_over_real = x_over_real[dummy_id]
            undefine, dummy_id
        endelse

    endfor

    ff = file_basename(file2restore)
    save, file = adsec_path.temp+"result_params_"+ff, params, residue, x_over_real, id_res, adsec_save, interf_wave, perror

    if keyword_set(WRITE_FILES) then begin
        if n_elements(ext) eq 0 then ext=""
        d0 = fltarr(adsec.n_actuators)
        d0[adsec.dummy_act] = adsec.d0[adsec.dummy_act]
        d0[adsec.act_w_cl] = params[0,*]
        cs = fltarr(adsec.n_actuators)
        cs[adsec.dummy_act] = adsec.d0[adsec.dummy_act]
        cs[adsec.act_w_cl] = params[1,*]
        openw, unit, adsec_path.temp+"d0_calibrated"+ext+".txt" ,/GET_LUN
        printf, unit, "float 48"
        printf, unit, d0
        free_lun, unit
        openw, unit, adsec_path.temp+"cr_calibrated"+ext+".txt" ,/GET_LUN
        printf, unit, "float 48"
        printf, unit, cs
        free_lun, unit
        print, "d0_calibrated.txt and cs_calibrated.txt write into temporary folder."
    endif

    act_coord_in = act_coord

    return, params

End
